
#include "Common.cfi"
#include "ModificatorVT.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "ShaderDrawType = Custom;"
           "ShaderType = FX;"
           "LocalConstants;"
           "PreprType = GenerateClouds;"
>;

/// Un-Tweakables //////////////////////
float4x4 CompMatrix  : PI_Composite;    // View*Projection
float4 CameraFrontVector : PB_CameraFront;

float4 LightningPos;
float4 LightningColSize;

float4 ImposterCameraPos;
float4 ImposterCameraFront;
float4 ImposterCameraUp;
float4 vCloudWSPos;					// VS constant
float4 g_CloudColorScale;		// PS constant, .x=Final Cloud Color Multiplier

float4 RTRect : PB_RTRect;

sampler2D baseMap : register(s0);
sampler2D depthMap : register(s1);
sampler2D hdrMap : register(s2);

sampler2D imposterMap
<
  string Script =
      "RenderOrder=PreProcess;"
      "ProcessOrder=Panorama;";
>;

float4 ScreenSize  : PB_ScreenSize;

struct pixout_clouds
{
  half4 Color  : COLOR0;
};

struct pixout_clear
{
  half4 Color0  : COLOR0;
  half4 Color1  : COLOR1;
  half4 Color2  : COLOR2;
  half4 Color3  : COLOR3;
};

struct app2vertCS
{
  IN_P
  IN_TBASE
  float3 viewDir : TEXCOORD1;
};

struct vert2frag
{
  float4 HPosition  : POSITION;
#ifdef PS3 || XENON
  float2 baseTC     : TEXCOORD0;
#else
  float2 baseTC     : TEXCOORD0_centroid;
#endif
  float3 vCamToPixel : TEXCOORD1;
  float3 vCamPosDiff : TEXCOORD2;
  float3 ImposterCameraFront : TEXCOORD3;
  float3 ImposterCameraUp : TEXCOORD4;
  float4 NearFar     : TEXCOORD5;
};

struct vert2fragImp
{
  float4 HPosition  : POSITION;
#ifdef PS3 || XENON
  float2 baseTC     : TEXCOORD0;
#else
  float2 baseTC     : TEXCOORD0_centroid;
#endif
  float3 posTC      : TEXCOORD1;  
#ifdef PS3 || XENON
  float  distOpac   : TEXCOORD2;
#else
  float  distOpac   : TEXCOORD2_centroid;
#endif
  
  float4 hPosTexProj : TEXCOORD3;
  float4 Color       : COLOR0;
  float3 Lightning	 : TEXCOORD4;
};

struct vert2fragCSImp
{
  float4 HPosition  : POSITION;
  float2 baseTC     : TEXCOORDN;
  float4 viewDir    : TEXCOORDN;
  float4 fogColor   : TEXCOORDN;
  float2 sceneDepthTC : TEXCOORDN;
  float  linearDepth : TEXCOORDN;
  float3 Lightning	 : TEXCOORDN;
  float4 NearFar     : TEXCOORDN; 
};

struct app2vertCloud
{
  IN_P
  IN_TBASE
  IN_C0
};

struct vert2fragCloud
{
  float4 HPosition  : POSITION;
  OUT_C0
  float2 baseTC     : TEXCOORD0;
};

struct pixout2
{
  float4 Color  : COLOR0;
  float  Depth  : DEPTH;
};

vert2frag ImposterVS(app2vertCloud IN)
{
	vert2frag OUT = (vert2frag)0; 

	// Position in screen space.
	float4 vPos = IN.Position;
	OUT.HPosition = mul(CompMatrix, vPos);
	OUT.NearFar = g_VS_NearFarClipDist;

	OUT.baseTC.xy = IN.baseTC.xy;

	return OUT;
}

vert2fragCloud TransformedClearVS(app2vertCloud IN)
{
  vert2fragCloud OUT = (vert2fragCloud)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = float4(2.0f * (vPos.xy + 0.5f) / IN.baseTC.xy - 1.0f, vPos.zw);
  OUT.baseTC = IN.baseTC;
  
  OUT.Color = GetInputColor(IN.Color);

  return OUT;
}

pixout_clear ClearPS(vert2fragCloud IN)
{
  pixout_clear OUT;

  OUT.Color0 = IN.Color;
  OUT.Color1 = IN.Color;
  OUT.Color2 = IN.Color;
  OUT.Color3 = IN.Color;

  return OUT;
}

vert2frag PanoramaClusterVS(app2vertCloud IN)
{
  vert2frag OUT = (vert2frag)0; 

  OUT.baseTC = IN.baseTC;

  // get position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(CompMatrix, vPos);

  // get view direction
  OUT.vCamToPixel = normalize(vPos - ImposterCameraPos).xyz;  

  // get camera positions difference in tangent space
  OUT.vCamPosDiff = ViewPos.xyz - ImposterCameraPos.xyz;
  
  OUT.ImposterCameraFront = ImposterCameraFront.xyz;
  OUT.ImposterCameraUp = ImposterCameraUp.xyz;
  
  return OUT;
}

vert2fragCloud TransformCloudVS(app2vertCloud IN)
{
  vert2fragCloud OUT = (vert2fragCloud)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(CompMatrix, vPos);
  
  OUT.baseTC.xy = IN.baseTC.xy;
  OUT.Color = GetInputColor(IN.Color);
  
  // Fade out at near clipping plane.
  // Zero opacity at near clipping plane AND "full opacity" when >= 1 meter away from near clipping plane
  //OUT.Color *= smoothstep( OUT.HPosition.w - g_VS_NearFarClipDist.x, 0.0, 1.0 ); 

  return OUT;
}

vert2fragImp TransformImposterVS(app2vertCloud IN)
{
  vert2fragImp OUT = (vert2fragImp)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(CompMatrix, vPos);
  
  OUT.baseTC.xy = (IN.baseTC.xy * RTRect.zw) + RTRect.xy;
  OUT.posTC.xyz = vPos.xyz;  
  
  // DO NOT SATURATE!!! We need per-pixel zero opacity at the far distance clipping plane
  //OUT.distOpac = 1 - pow( saturate( OUT.HPosition.w * g_VS_NearFarClipDist.w ), 10 );  
  OUT.distOpac = 1 - pow( OUT.HPosition.w * g_VS_NearFarClipDist.w, 10 ); 

  OUT.hPosTexProj = HPosToScreenTC(OUT.HPosition);

  OUT.Color = GetInputColor(IN.Color);
  
  // Fade out at near clipping plane.
  // Zero opacity at near clipping plane AND "full opacity" when >= 1 meter away from near clipping plane
  //OUT.Color *= smoothstep( OUT.HPosition.w - g_VS_NearFarClipDist.x, 0.0, 1.0 ); 
       
  float3 attenDist = 0.05 * LightningColSize.w * ( vPos.xyz - LightningPos.xyz );
  float lightning = 1 / ( 1 + dot( attenDist, attenDist ) );
  OUT.Lightning = LightningColSize.xyz * lightning;

  return OUT;
}

vert2fragCSImp TransformCSImposterVS(app2vertCS IN)
{
  vert2fragCSImp OUT = (vert2fragCSImp)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(CompMatrix, vPos);
  OUT.baseTC.xy = (IN.baseTC.xy * RTRect.zw) + RTRect.xy;
  OUT.viewDir.xyz = IN.viewDir.xyz;
  OUT.fogColor = GetVolumetricFogColor( vCloudWSPos.xyz );
  OUT.viewDir.a = LightningPos.a;

	#define zNear		g_VS_NearFarClipDist.x
	#define zFar		g_VS_NearFarClipDist.y
	#define zPersp	OUT.HPosition.z
	
	OUT.NearFar = g_VS_NearFarClipDist;

	float a = zFar / ( zFar - zNear );
	float b = zNear * -a;
	float zLinear = b / ( zPersp - a );
  
  OUT.sceneDepthTC = HPosToScreenTC(OUT.HPosition);
  //OUT.sceneDepthTC.xy = IN.baseTC.xy; // copying input texture uv's doesn't work with high res screenshot option...
  //OUT.sceneDepthTC.x = (  OUT.HPosition.x + OUT.HPosition.w ) * 0.5; // ... instead, map to screen using homogenous position and perform clamped texture lookup
  //OUT.sceneDepthTC.y = ( -OUT.HPosition.y + OUT.HPosition.w ) * 0.5;
  //OUT.sceneDepthTC.xy += 0.5 * OUT.HPosition.w;  // no need to add half a texel since we're drawing a full screen quad
  //OUT.sceneDepthTC.xy /= OUT.HPosition.w; // no need for perspective divide as w=1, always
    
  OUT.linearDepth = zLinear;
  
  float3 attenDist = 0.05 * LightningColSize.w * ( vfViewPos.xyz - LightningPos.xyz );
  float lightning = 1 / ( 1 + dot( attenDist, attenDist ) );
  OUT.Lightning = LightningColSize.xyz * lightning;
  
  return OUT;
}

pixout ImposterPS(vert2frag IN)
{
  pixout OUT;

  half4 vTex = tex2D(imposterMap, IN.baseTC.xy);
  half4 vDepth = GetLinearDepth(depthMap, IN.baseTC.xy);
  float fDepth = lerp(PS_ZRange.x, PS_ZRange.y, vTex.a);
  OUT.Color = vTex;
  float fLinearZ = (PS_ZRange.w / (fDepth - PS_ZRange.z)) * IN.NearFar.w;
//  OUT.Color1 = (vDepth.a == 0) ? 1 : max(fLinearZ, 0.0001);
//  OUT.Depth  = (vDepth.a == 0) ? 1 : fDepth;

  return OUT;
}

pixout2 PanoramaClusterPS(vert2frag IN)
{
  // make world to tangent space matrix
  float3 v0 = -normalize(IN.vCamToPixel);
  float3 v1 = -cross(v0,IN.ImposterCameraUp);  
  float3 v2 = cross(v1,v0);
  float3x3 matTangent = 
  {
	v1[0], v1[1], v1[2],
	v2[0], v2[1], v2[2],
	v0[0], v0[1], v0[2],
  };
  
  // get camera positions difference in tangent space
  float3 vCamPosDiff = mul(matTangent,IN.vCamPosDiff);

  // do parallax mapping
  half fDepth01 = tex2D(imposterMap, IN.baseTC).a;
  float fDepthMeters = lerp(PS_ZRange.x, PS_ZRange.y, fDepth01);  
  IN.baseTC.xy += vCamPosDiff.xy / max(1, fDepthMeters);

  // read texel from new position
  half4 vTex = tex2D(imposterMap, IN.baseTC);
   
  // get linear distance for fog
  float fLinearZ_Meters_WS = lerp(PS_ZRange.x, PS_ZRange.y, vTex.a);
  float3 vCamRelPos = normalize(IN.vCamToPixel) * fLinearZ_Meters_WS;
  float NearPlaneLinearDist = dot(CameraFrontVector.xyz, vCamRelPos);
  float fRange = PS_ZRange.w - PS_ZRange.z;
  float fLinearZ_01_OrigCamera = NearPlaneLinearDist / fRange;  

  // get non linear dist
  float fNonLinarDist =	(PS_ZRange.z - NearPlaneLinearDist) * PS_ZRange.w / (-fRange * NearPlaneLinearDist);

  pixout2 OUT;
  
  OUT.Color = vTex; // RGB
 
  OUT.Depth = (vTex.a == 1) ? 1 : min(fNonLinarDist+0.005f,.9999f); // depth  

  return OUT;
}

pixout_clouds CloudPS(vert2fragCloud IN)
{
  pixout_clouds OUT;

  half4 vTex = tex2D(baseMap, IN.baseTC.xy); 
  OUT.Color =  half4( vTex.xyz * IN.Color.xyz, vTex.w ) * IN.Color.w;

  return OUT;
}

float CloudAngularAtten
<
  psregister = PS_REG_PM_4.x;
  string UIHelp = "Angular attenuation factor for cloud back lighting";                     
  string UIName = "CloudAngularAtten";    
  
  string UIWidget = "slider";
  float UIMin = 1.0;
  float UIMax = 100.0;
  float UIStep = 0.25;
> = 30.0;

float CloudOutlineThreshold
<
  psregister = PS_REG_PM_4.y;
  string UIHelp = "Opacity threshold to generate cloud outline for back lighting";                     
  string UIName = "CloudOutlineThreshold";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.01;
> = 0.4;

float CloudOutlineSlope
<
  psregister = PS_REG_PM_4.z;
  string UIHelp = "Slope to generate cloud outline for back lighting";                     
  string UIName = "CloudOutlineSlope";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 20.0;
  float UIStep = 0.1;
> = 1.0;

float CloudBacklightingScale
<
  psregister = PS_REG_PM_4.w;
  string UIHelp = "Scale back lighting result";                     
  string UIName = "CloudBacklightingScale";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 5.0;
  float UIStep = 0.1;
> = 1.0;

half3 ApplyBackLighting( in half4 cloudColor, in half3 viewDir )
{
/*
  half mask = ( 1.1 - 0.9 * cloudColor.w );  
  float spec = pow( saturate( dot( normalize( viewDir  ), g_PS_SunLightDir.xyz ) ), CloudAngularAtten );  
  half3 col = cloudColor.xyz + 1.5 * cloudColor.w * mask * mask * spec * g_PS_SunColor; 
*/
	half arg = 0.5 + ( -cloudColor.w + CloudOutlineThreshold ) * CloudOutlineSlope;
  half mask = saturate( arg );    
  float spec = CloudBacklightingScale * pow( saturate( dot( normalize( viewDir  ), g_PS_SunLightDir.xyz ) ), CloudAngularAtten );  
  half3 col = cloudColor.xyz + cloudColor.w * mask * spec * g_PS_SunColor.xyz; 
  //half3 col = mask; 

	return( col );
}

float HDRBrightnessAdjust
<
  psregister = PS_REG_PM_3.x;
  string UIHelp = "Controls brightness of clouds on HDR (relative to LDR)";
  string UIName = "HDRBrightnessAdjust";
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 5.0;
  float UIStep = 0.1;
> = 1.0;

pixout CloudImposterPS(vert2fragImp IN)
{
  pixout OUT;

 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, float4(IN.baseTC.xy, 0, 0));
   return OUT;
 #endif

  half4 vTex = tex2D(baseMap, IN.baseTC.xy) * saturate( IN.distOpac );
  half4 vFog = GetVolumetricFogColor(IN.posTC);	
  half alpha = vTex.w;
  half3 vFinalCol = ApplyBackLighting( vTex, IN.posTC - vfViewPos.xyz );

	vFinalCol.xyz *= g_CloudColorScale.x;		// needed for HDR
#ifdef %_RT_HDR_MODE
	vFinalCol.xyz *= HDRBrightnessAdjust;
#endif	
	vFinalCol.xyz += IN.Lightning.xyz * alpha;
		

  half4 vRes = half4( lerp( vFog.xyz * alpha, vFinalCol.xyz, vFog.w ).xyz, alpha );    
	vRes.xyz = lerp( AvgFogVolumeContrib.xyz * vRes.w, vRes.xyz, AvgFogVolumeContrib.w );			  
	float sceneDepth = DecodeSceneDepth( depthMap, IN.hPosTexProj );
	float scale = saturate( ( sceneDepth - IN.hPosTexProj.w ) * 0.05 );

	vRes *= scale * IN.Color.a;
	
  HDROutput( OUT, vRes, 1);   
  
  return OUT;
}

pixout Cloud_RecursivePS(vert2fragImp IN)
{
  pixout OUT;

  half4 vTex = tex2D(baseMap, IN.baseTC.xy) * saturate( IN.distOpac );
  half4 vFog = GetVolumetricFogColor(IN.posTC);	
  half3 vFinalCol = vTex.xyz * IN.Color.xyz * IN.Color.w;
	vFinalCol.xyz *= g_CloudColorScale.x;		// needed for HDR
#ifdef %_RT_HDR_MODE
	vFinalCol.xyz *= HDRBrightnessAdjust;
#endif		
  half alpha = vTex.w * IN.Color.w;
		
  half4 vRes = half4( lerp( vFog.xyz * alpha, vFinalCol.xyz, vFog.w ).xyz, alpha );  

  HDROutput( OUT, vRes, 1);   
  return OUT;
}

pixout CloudScreenImposterPS(vert2fragCSImp IN)
{
  pixout OUT;

 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, float4(IN.baseTC.xy, 0, 0));
   return OUT;
 #endif

  half4 vTex = tex2D(baseMap, IN.baseTC.xy);
  half4 vFog = IN.fogColor;	
	half alpha = vTex.w;	
	half3 color = ApplyBackLighting( vTex, IN.viewDir.xyz );
	
	color.xyz *= g_CloudColorScale.x;		// needed for HDR
#ifdef %_RT_HDR_MODE
	color.xyz *= HDRBrightnessAdjust;
#endif		
	color.xyz += IN.Lightning.xyz * alpha;	

	float sceneDepth = GetLinearDepth( depthMap, IN.sceneDepthTC.xy );
	float scale = saturate( ( sceneDepth * IN.NearFar.y - IN.linearDepth ) * 0.05 );    	

	half4 finalColor = half4( lerp( vFog.xyz * alpha, color.xyz, vFog.w ).xyz, alpha );
	finalColor.xyz = lerp( AvgFogVolumeContrib.xyz * alpha, finalColor.xyz, AvgFogVolumeContrib.w );	
	finalColor *= scale * IN.viewDir.a;

	HDROutput( OUT, finalColor, 1 );
  return OUT;
}

vert2frag ImposterPostVS(app2vertCloud IN)
{
  vert2frag OUT = (vert2frag)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(CompMatrix, vPos);
  
  OUT.baseTC.xy = IN.baseTC.xy; // + PixelOffset.xy * 0.5;

  return OUT;
}

pixout_clouds ImposterPostPS(vert2frag IN)
{
  pixout_clouds OUT;

 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, float4(IN.baseTC.xy, 0, 0));
   return OUT;
 #endif

  half4 vTex = tex2D(baseMap, IN.baseTC.xy);
  half4 vDepth = GetLinearDepth( depthMap, IN.baseTC.xy );
  OUT.Color.xyz = vTex.xyz;
  OUT.Color.a = vTex.a;

  return OUT;
}


//========================================================================

technique PanoramaCluster
{
  pass p0
  {
    VertexShader = compile vs_Auto PanoramaClusterVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto PanoramaClusterPS();
  }
}

technique Imposter
{
  pass p0
  {
    VertexShader = compile vs_Auto ImposterVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto ImposterPS();
  }
}

technique ImposterPostProcess
{
  pass p0
  {
    VertexShader = compile vs_Auto ImposterPostVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto ImposterPostPS();
  }
}

technique Cloud
<
  string Script = "Public;";
>
{
  pass p0
  {
    VertexShader = compile vs_Auto TransformCloudVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto CloudPS();
  }
}

technique Cloud_Recursive
{
  pass p0
  {
    VertexShader = compile vs_Auto TransformImposterVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_Auto Cloud_RecursivePS();
  }
}

technique Cloud_Imposter
{
  pass p0
  {
    VertexShader = compile vs_Auto TransformImposterVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
       
    PixelShader = compile ps_Auto CloudImposterPS();
  }
}

technique Cloud_ScreenImposter
{
  pass p0
  {
    VertexShader = compile vs_Auto TransformCSImposterVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
   
    PixelShader = compile ps_Auto CloudScreenImposterPS();
  }
}

technique Clear
{
  pass p0
  {
    VertexShader = compile vs_Auto TransformedClearVS();
    
    ZEnable = false;
    CullMode = None;
       
    PixelShader = compile ps_Auto ClearPS();
  }
}

/////////////////////// eof ///

