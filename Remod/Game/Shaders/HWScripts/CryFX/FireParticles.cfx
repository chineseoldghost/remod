

// - move into Particles.cfi

#include "Common.cfi"
#include "ParticleVT.cfi"

float Script : STANDARDSGLOBAL
<
  string Script =
           "Public;"
           "NoPreview;"           
           "ShaderDrawType = Light;"
           "ShaderType = Particle;"
>;

/// Un-Tweakables //////////////////////

DIFFUSEMAP
GLOSSMAP 
BUMPMAP
BUMPDIFFUSEMAP

sampler3D frostyNoiseMapSampler = sampler_state
{  
  Texture = textures/defaults/Noise3D.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
  AddressW = Wrap;
};

sampler2D frostBumpPatternSampler = sampler_state
{    
  Texture = textures/defaults/frostBumpPattern.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D sceneDepthSampler = sampler_state
{
 Texture = $ZTarget;
 MinFilter = POINT;
 MagFilter = POINT;
 MipFilter = POINT;
 AddressU = Clamp;
 AddressV = Clamp;
};

// Tweakables /////////////////

float BurnAmount
<
  psregister = PS_REG_PM_3.x;
  vsregister = VS_REG_PM_4.y;
  string UIHelp = "Burning amount";                   
  string UIName = "Burn amount";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.005;
> = 1.0;

float BaseDarkening
<
  psregister = PS_REG_PM_3.y;
  string UIHelp = "Set base layer darkening amount";                   
  string UIName = "Base layer darkening amount";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.005;
> = 0.4;

float BurnOffset
<
  vsregister = VS_REG_PM_4.z;
  string UIHelp = "Set burn variation layer offsetting. Use for giving more variation to burn.";                   
  string UIName = "Burn offset";    
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 1000.0;
  float UIStep = 0.005;
> = 0.1;

float VariationTileU
< 
  vsregister = VS_REG_PM_5.x;
  string UIHelp = "Set burn volumetric tilling in U axis";                   
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.005;
> = 0.2;

float VariationTileV
<
  vsregister = VS_REG_PM_5.y;
  string UIHelp = "Set burn volumetric tilling in V axis";                   

  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.005;
> = 0.2;

float VariationTileW
<
  vsregister = VS_REG_PM_5.w;
  string UIHelp = "Set burn volumetric tilling in W axis";                   
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.005;
> = 0.1;

float DetailTile
<
  vsregister = VS_REG_PM_5.z;
  string UIHelp = "Set fire detail layer tilling";                   
  string UIName = "Fire detail tile";   
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.005;
> = 0.02;

float AnimSpeed
<
  vsregister = VS_REG_PM_4.w;
  string UIHelp = "Set fire animation translation speed";                   
  string UIName = "Fire translation speed";   
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 100.0;
  float UIStep = 0.005;
> = 1.0;

float4 StartColor
<
  psregister = PS_REG_PM_4;
  string UIHelp = "Set start fire layer color";                   
  string UIName = "Start fire color";    

  string UIWidget = "color";
> = { 0.7, 0.392, 0.094, 1.0 };

float4 EndColor
<
  psregister = PS_REG_PM_5;
  string UIHelp = "Set end fire layer color";                   
  string UIName = "End fire color";    

  string UIWidget = "color";
> = { 0.215, 0.137, 0.039, 1.0 };

/////////// Common vertex shader ////////////////

struct vtxCommonOut
{ 
  float4 Position  : POSITION;
     
  float4 tcBase : TEXCOORDN;  
  float4 tcDetail : TEXCOORDN;
  
  float4 tcPos0 : TEXCOORDN;      
  float4 tcPos1 : TEXCOORDN; 
  
  float4 tcProj : TEXCOORDN;
  
#ifdef %_RT_SOFT_PARTICLE
	float4 hPosTexProj  : TEXCOORDN;
	float4 particleFade : TEXCOORDN;
#endif

  float4 Color     : COLOR0;  

  float4 localFogColor : TEXCOORDN;
};

vtxCommonOut FireVS(app2vertParticleGeneral IN)
{
  vtxCommonOut OUT; 
#ifndef OPENGL  
  OUT = (vtxCommonOut)0; 
#endif  
  
  //////////////////////////////////////////////////////
  // Setup particle
  
  vert2FragParticleGeneral outParticle;    
  float4 vPos = IN.Position; 
  
#ifdef D3D10
  IN.Expansion.xyzw = IN.Expansion.zyxw;
#endif  
  IN.Expansion.xy = IN.Expansion.xy * 2.0 - 1.0;
  
  Particle_Setup_General( vPos, g_VS_ViewProjMatr, IN, outParticle);
  
  OUT.Position = outParticle.Position;
  
  #ifdef %_RT_SOFT_PARTICLE    
    OUT.particleFade = outParticle.particleFade;    
  #endif

  //////////////////////////////////////////////////////
  // procedural textures generation setup

  OUT.tcBase.xy = IN.baseTC.xy;
  OUT.tcDetail.xy = IN.baseTC.xy * DetailTile ;
  
  OUT.Color = GetInputColor(IN.Color);
    
  const float fParticleSize = 20;
    
  // Make sure we don't get into ATI precision isses by rescaling values. 
  // Cannot use particle radius, since it's not constant size (would look strange in movement)
  
  // Get vertex position in "particle space". Add fractional part from world position particle mid-point for variation
  float3 vPosRescaled = vPos.xyz; //(vPos.xyz - IN.Position.xyz) + frac(IN.Position.xyz /fParticleSize) * fParticleSize;
  
  float3 vVariationTilling = float3(VariationTileU, VariationTileV, VariationTileW);
  
  OUT.tcPos0.xyz = vPosRescaled.xyz * vVariationTilling + float3(0, 0, -frac(g_VS_AnimGenParams.z * AnimSpeed)) + BurnOffset.xxx;
  OUT.tcPos1.xyz = vPosRescaled.xyz * vVariationTilling * 2  + float3(0, 0, -frac(g_VS_AnimGenParams.z * AnimSpeed)) + BurnOffset.xxx;
    
  // Compute some common coeficients from vertex shader to save pixel shader instructions
  OUT.tcBase.z = BurnAmount - 1.5;
  OUT.tcBase.w = BurnAmount - 1.5;
    
	// Output the screen-space texture coordinates
	OUT.tcProj.x = (OUT.Position.x * 0.5 + OUT.Position.w * 0.5);
	OUT.tcProj.y = (OUT.Position.w * 0.5 - OUT.Position.y * 0.5);
	OUT.tcProj.zw = OUT.Position.ww;  
	


  OUT.localFogColor = GetVolumetricFogColor( vPos );  
  return OUT;
}


///////////////// pixel shader //////////////////

pixout FirePS(vtxCommonOut IN)
{
  pixout OUT;  

  half4 cBump = half4(0,0,1,1);
  
  float2 tcProj = (IN.tcProj.xy / IN.tcProj.w);
  half4 cPerturbation = tex2D(frostBumpPatternSampler, tcProj* 0.025)*2-1;
  cPerturbation.xy += 0.1 * (tex2D(frostBumpPatternSampler, tcProj*0.25).xy*2-1);
  cPerturbation.xyz = normalize(cPerturbation.xyz);
  
 #if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
   DebugOutput(OUT.Color, IN.tcBase);
   return OUT;
 #endif
  
  half4 cBase = tex2D(diffuseMapSampler, IN.tcBase.xy); 
  
  // accumulate 2 noise patterns to smooth tilling pattern
  half fNoise = tex3D(frostyNoiseMapSampler, IN.tcPos0.xyz).w;
  fNoise += tex3D(frostyNoiseMapSampler, IN.tcPos1.xyz).w;
    
  half fDetail = saturate(tex2D(frostBumpPatternSampler, IN.tcDetail.xy).w);
          
  // Compute base variation
  half fVariation = saturate(0.5 * fNoise * fNoise * fDetail);      
        
  half3 cBaseLayer = 0;
  cBaseLayer.x = fDetail;
  cBaseLayer.y = tex2D(frostBumpPatternSampler, IN.tcDetail.xy*4).w;
  cBaseLayer.z = tex2D(frostBumpPatternSampler, IN.tcDetail.xy*8).w;
  
  // Compute procedural transition/growing
  half2 fCommonPatternGrow = (fVariation + IN.tcBase.zw);      
  
  // Vectorize grow transition for 4 layer
  half4 vCommonGrow = half4( fCommonPatternGrow.x*3 , fCommonPatternGrow.y *5, fCommonPatternGrow.y *7, fCommonPatternGrow.y*7);
  vCommonGrow *= vCommonGrow;  
  vCommonGrow = saturate(1 - vCommonGrow);  
    
  cBump.xyz += EXPAND(tex2D(frostBumpPatternSampler, IN.tcDetail.xy)).xyz;
  cBump.xy *= vCommonGrow.x * (half) BurnAmount;
  
  // Compute procedural transitions
  half3 fTransition = 0;
  half fDarkening = 0;
  half4 cLayerAccum = 0;     
    
  // Accumulate results, using burn transition for variation
  fTransition = vCommonGrow.x * cBaseLayer.x;  
  cLayerAccum.xyz =  fTransition * ((half3) StartColor);    
  fDarkening = fTransition;  
      
  fTransition = vCommonGrow.y * cBaseLayer.y;           
  cLayerAccum.xyz += fTransition * ((half3) StartColor) ;
  fDarkening += fTransition;
      
  half3 fMedLayer = (vCommonGrow.z * cBaseLayer.z * vCommonGrow.z * cBaseLayer.y * (half3) EndColor);
  half3 fTopLayer = (vCommonGrow.w * cBaseLayer.z * (half3) EndColor);
  
  // medium strength layer + strong sharp layer
  cLayerAccum.xyz += fMedLayer + (fTopLayer * 4);  
  
  half4 cFinal  =0;
  cFinal.xyz = 2 * IN.Color.w * cBase.w * cLayerAccum.xyz * ( fDarkening + cBaseLayer.z ) * BaseDarkening;
  
  // Output alpha for semi-opaque and darkening areas
  cFinal.w = IN.Color.w * cBase.w * ( fDarkening + cBaseLayer.z) * BaseDarkening;
  

  cFinal *= saturate(IN.localFogColor.w);
	cFinal.xyz *= AvgFogVolumeContrib.w;	

//cFinal.xyz = IN.tcPos0.xyz/50;
//cFinal.w = 0;

  HDROutput( OUT, cFinal, 1 );
  
#ifdef %_RT_SOFT_PARTICLE

  ////////////////////////////////////////////////////////////////
  // evaluate travel length through particle volume to fade
  // out particle when getting close to scene geometry
#define cameraFade							IN.particleFade.x
#define particleThicknessInv		IN.particleFade.y
#define particleRadius					IN.particleFade.z
#define particleDepth						IN.particleFade.w
#define sceneDepthTexLookup			IN.tcProj

  float sceneDepth = DecodeSceneDepth( sceneDepthSampler, sceneDepthTexLookup );
  float scaleBackground = saturate( ( sceneDepth - particleDepth ) * particleThicknessInv );
  float fadeParticle = min( scaleBackground, cameraFade );

  OUT.Color *= fadeParticle;
#endif

  return OUT;
}

//////////////////////////////// technique ////////////////

technique General
{
  pass p0
  {
    VertexShader = compile vs_Auto FireVS();
    PixelShader = compile ps_Auto FirePS();
    
    ZEnable = true;
    ZWriteEnable = false;
    CullMode = None;
    ZFunc = LEqual;
    
    SrcBlend =  ONE;
    DestBlend = ONE_MINUS_SRC_ALPHA;
    AlphaBlendEnable = true;                
  }    
}

/////////////////////// eof ///

