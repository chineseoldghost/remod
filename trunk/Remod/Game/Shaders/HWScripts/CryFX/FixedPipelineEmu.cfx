#include "Common.cfi"
#include "ModificatorVT.cfi"

// Color/Alpha arguments
#define CA_SPECULAR 0
#define CA_TEXTURE  1
#define CA_DIFFUSE  2
#define CA_PREVIOUS 3
#define CA_TFACTOR  4

// Color/Alpha operations
#define CO_DISABLE    1
#define CO_SELECTARG1 2
#define CO_DECAL      3
#define CO_SELECTARG2 4
#define CO_MODULATE   5
#define CO_MODULATE2X 6
#define CO_MODULATE4X 7
#define CO_BLENDDIFFUSEALPHA 8
#define CO_BLENDTEXTUREALPHA 9
#define CO_DETAIL     10
#define CO_ADD        11
#define CO_ADDSIGNED  12
#define CO_ADDSIGNED2X 13
#define CO_MULTIPLYADD 14
#define CO_BUMPENVMAP  15
#define CO_BLEND       16
#define CO_MODULATEALPHA_ADDCOLOR 17
#define CO_MODULATECOLOR_ADDALPHA 18
#define CO_MODULATEINVALPHA_ADDCOLOR 19
#define CO_MODULATEINVCOLOR_ADDALPHA 20
#define CO_DOTPRODUCT3 21
#define CO_LERP        22
#define CO_SUBTRACT    23

/// Un-Tweakables //////////////////////
float4x4 compMatrix  : PI_Composite  < register = c0; >; // View*Projection
float4   TFactor   : PB_TFactor;

sampler2D Texture0 = sampler_state
{
  Texture = $White;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR;
};

samplerCUBE TextureCube0 = sampler_state
{
  Texture = $White;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR;
};

/////////////////////////////

struct a2v
{
  float4 Position : POSITION; //in object space
  float2 baseTC   : TEXCOORD0;
  float4 Color    : COLOR0;
};

struct v2f
{
  float4 Position  : POSITION;  //in projection space
#if %_FT_TEXTURE
  float2 baseTC    : TEXCOORD0;
#endif  
#if %_FT_DIFFUSE
  float4 Color     : COLOR0;
#endif  
};

///////////////// vertex shader //////////////////
v2f FPVS(a2v IN)
{
  v2f OUT = (v2f)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.Position = mul(compMatrix, vPos);
  
#if %_FT_TEXTURE
  OUT.baseTC = IN.baseTC;
#endif  
#if %_FT_DIFFUSE
  OUT.Color = GetInputColor(IN.Color);
#endif  

  return OUT;
}

///////////////// pixel shader //////////////////

void GetRGBArg(int nType, inout half4 Arg, half4 PrevArg, half4 baseTex, half4 INColor, half4 INColor1, half4 TFactor)
{
  if (nType == CA_TEXTURE)
    Arg.xyz = baseTex.xyz;
  else
  if (nType == CA_DIFFUSE)
  {
#if OPENGL
    Arg.xyz = INColor.bgr;
#else
    Arg.xyz = INColor.rgb;
#endif    
  }
  else
  if (nType == CA_SPECULAR)
    Arg.xyz = INColor1.xyz;
  else
  if (nType == CA_TFACTOR)
    Arg.xyz = TFactor.xyz;
  else
  if (nType == CA_PREVIOUS)
    Arg.xyz = PrevArg.xyz;
}

void GetAlphaArg(int nType, inout half4 Arg, half4 PrevArg, half4 baseTex, half4 INColor, half4 INColor1, half4 TFactor)
{
  if (nType == CA_TEXTURE)
    Arg.w = baseTex.w;
  else
  if (nType == CA_DIFFUSE)
    Arg.w = INColor.w;
  else
  if (nType == CA_SPECULAR)
    Arg.w = INColor1.w;
  else
  if (nType == CA_TFACTOR)
    Arg.w = TFactor.w;
  else
  if (nType == CA_PREVIOUS)
    Arg.w = PrevArg.w;
}

void RGBColorOp(int nType, inout half4 resColor, half4 Arg1, half4 Arg2, half4 baseTex, half4 INColor)
{
  if (nType == CO_MODULATE)
    resColor.xyz = Arg1.xyz * Arg2.xyz;
  else
  if (nType == CO_SELECTARG1)
    resColor.xyz = Arg1.xyz;
  else
  if (nType == CO_SELECTARG2)
    resColor.xyz = Arg2.xyz;
  else
  if (nType == CO_ADD)
    resColor.xyz = Arg1.xyz + Arg2.xyz;
  else
  if (nType == CO_MODULATE2X)
    resColor.xyz = Arg1.xyz * Arg2.xyz * 2;
  else
  if (nType == CO_MODULATE4X)
    resColor.xyz = Arg1.xyz * Arg2.xyz * 4;
  else
  if (nType == CO_BLENDDIFFUSEALPHA)
    resColor.xyz = Arg1.xyz * INColor.a + Arg2.xyz * (1-INColor.a);
  else
  if (nType == CO_BLENDTEXTUREALPHA)
    resColor.xyz = Arg1.xyz * baseTex.a + Arg2.xyz * (1-baseTex.a);
  else
  if (nType == CO_ADDSIGNED)
    resColor.xyz = Arg1.xyz + Arg2.xyz - 0.5;
  else
  if (nType == CO_ADDSIGNED2X)
    resColor.xyz = (Arg1.xyz + Arg2.xyz - 0.5) * 2;
  else
  if (nType == CO_MODULATEALPHA_ADDCOLOR)
    resColor.xyz = Arg1.xyz + Arg1.w * Arg2.xyz;
  else
  if (nType == CO_MODULATECOLOR_ADDALPHA)
    resColor.xyz = Arg1.xyz * Arg2.xyz + Arg1.w;
  else
  if (nType == CO_MODULATEINVALPHA_ADDCOLOR)
    resColor.xyz = Arg1.xyz + Arg2.xyz + (1-Arg1.w);
  else
  if (nType == CO_MODULATEINVCOLOR_ADDALPHA)
    resColor.xyz = (1-Arg1.xyz) * Arg2.xyz + Arg1.w;
  else
  if (nType == CO_DOTPRODUCT3)
    resColor.xyz = dot(Arg1.xyz, Arg2.xyz);
  else
  if (nType == CO_SUBTRACT)
    resColor.xyz = Arg1.xyz - Arg2.xyz;
}

void AlphaColorOp(int nType, inout half4 resColor, half4 Arg1, half4 Arg2, half4 baseTex, half4 INColor)
{
  if (nType == CO_MODULATE)
    resColor.w = Arg1.w * Arg2.w;
  else
  if (nType == CO_SELECTARG1)
    resColor.w = Arg1.w;
  else
  if (nType == CO_SELECTARG2)
    resColor.w = Arg2.w;
  else
  if (nType == CO_ADD)
    resColor.w = Arg1.w + Arg2.w;
  else
  if (nType == CO_MODULATE2X)
    resColor.w = Arg1.w * Arg2.w * 2;
  else
  if (nType == CO_MODULATE4X)
    resColor.w = Arg1.w * Arg2.w * 4;
  else
  if (nType == CO_ADDSIGNED)
    resColor.w = Arg1.w + Arg2.w - 0.5;
  else
  if (nType == CO_ADDSIGNED2X)
    resColor.w = (Arg1.w + Arg2.w - 0.5) * 2;
  else
  if (nType == CO_SUBTRACT)
    resColor.w = Arg1.w - Arg2.w;
}

pixout FPPS(v2f IN)
{
  pixout OUT;

  // load the base
  half4 baseTex = (float4)0; 
  half4 Arg01 = (float4)0;
  half4 Arg02 = (float4)0;

  half4 INDiffuse = (float4)0;
  half4 INSpecular = (float4)0;
#if %_FT_TEXTURE
  baseTex = tex2D(Texture0, IN.baseTC.xy);
#endif  
#if %_FT_DIFFUSE
  INDiffuse = IN.Color;
#endif

  GetRGBArg(%_FT0_CARG1, Arg01, Arg01, baseTex, INDiffuse, INSpecular, TFactor);
  GetRGBArg(%_FT0_CARG2, Arg02, Arg02, baseTex, INDiffuse, INSpecular, TFactor);
  GetAlphaArg(%_FT0_AARG1, Arg01, Arg01, baseTex, INDiffuse, INSpecular, TFactor);
  GetAlphaArg(%_FT0_AARG2, Arg02, Arg02, baseTex, INDiffuse, INSpecular, TFactor);
  
  half4 resColor = (half4)0;
  RGBColorOp(%_FT0_COP, resColor, Arg01, Arg02, baseTex, INDiffuse);
  AlphaColorOp(%_FT0_AOP, resColor, Arg01, Arg02, baseTex, INDiffuse);
      
  OUT.Color = resColor;
  
  return OUT;
}

//////////////////////////////// technique ////////////////

technique FixedPipeline
{
  pass p0
  {
    VertexShader = compile vs_1_1 FPVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile ps_1_1 FPPS();
  }
}

/////////////////////// eof ///
