#include "Common.cfi"
#include "ShadeLib.cfi"
#include "ModificatorVT.cfi"

#define USE_EXP_TONEMAPPING

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "NoPreview;"
           "LocalConstants;"
           "ShaderDrawType = Custom;"
           "ShaderType = HDR;"
>;

/// Un-Tweakables //////////////////////
float4 ScreenSize  : PB_ScreenSize;

float4 SampleOffsets[16] < register = c0; >
float4 SampleWeights[16] < register = c16; >
float4x4 HDRColorMatrix;

float4 HDRParams0;				// (r_hdreyeadaptationfactor,r_hdrbrightoffset,r_hdrbrightthreshold,r_HDRLevel)
float4 HDRParams1;				// (r_hdreyeadaptationbase,*,*,*)
float4 HDRParams2;				// (*, *, vignetting threshold, vignetting amount)
float4 HDRGamma;					// (m_LumGamma.LowPercentil,m_LumGamma.MidPercentil,m_LumGamma.HighPercentil,m_LumGamma.Bias)

#define PROFILE_PS ps_2_0
#define PROFILE_VS vs_2_0

float ElapsedTime;
float4 FrameRand;
float Time = {PB_time};

float g_fBloomScale = 2.5f;

sampler2D zMap : register(s0);
sampler2D sceneMap0 : register(s0);
sampler2D sceneMap1 : register(s1);
sampler2D sceneMap2 : register(s2);
sampler2D noiseMap : register(s4);
sampler2D colorChartMap : register(s5);

sampler2D baseMap : register(s0);
sampler2D bloomMap : register(s1);

sampler2D lumMap    : register(s2);
sampler2D lumMap0    : register(s0);
sampler2D lumMap1    : register(s1);


struct app2vert
{
  IN_P
  IN_TBASE
  IN_C0
};

struct app2vertFog
{
  IN_P
  float3 CamVec    : TEXCOORD0;
};

struct vert2frag
{
  float4 HPosition  : POSITION;
  float2 baseTC     : TEXCOORD0;
  float2 baseTCRnd  : TEXCOORD1;
};

struct vert2fragFog
{
  float4 HPosition  : POSITION; 
  float2 baseTC       : TEXCOORD0;
  float3 CamVec       : TEXCOORD1;
};

// ----------------------------------------------------------------------------------

// RangeReducedAdaptedLum
half EyeAdaption( half fSceneLuminance )
{
#ifdef USE_EXP_TONEMAPPING
	half ret = lerp(HDRParams1.x,fSceneLuminance,HDRParams0.x);	// good values: r_hdreyeadaptationbase=0.25, r_hdreyeadaptationfactor=0.5
#else
	// reinhard white-point
	half ret = lerp(HDRParams1.x,fSceneLuminance,HDRParams0.x); // good values: r_hdreyeadaptationbase=0.2, r_hdreyeadaptationfactor=0.35
#endif	
	
//	ret*=2.0f;		// hack for testing in storage

//	ret =max(ret,0.2f);
	
	return ret;
}

// Note: DirectX will skip the vshader for vformats containing a transformed
// position (VERTEX_FORMAT_TRP3F_*). The PreTransformedVS shader is executed
// only for platforms that do not support pre-transformed verts (e.g. OpenGL).
vert2frag PreTransformedVS(app2vert IN)
{
  vert2frag OUT = (vert2frag)0; 

	// Position in pixel coordinates (i.e. 0 thru ScreenSize - 1).
  float4 vPos = IN.Position;
  OUT.HPosition = float4(
			2.0f * (vPos.xy + 0.5f) / ScreenSize.xy - 1.0f, vPos.zw);
  OUT.baseTC.xy = IN.baseTC.xy;

  return OUT;
}

vert2frag TransformedVS(app2vert IN)
{
  vert2frag OUT = (vert2frag)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = vPos;
  
  float2 baseTC = vPos.xy * float2(0.5, -0.5) + 0.5;
#if !D3D10 && !PS3
  OUT.HPosition.xy += float2(-0.5, 0.5) * g_VS_ScreenSize.zw;
#endif
  
  OUT.baseTC.xy = baseTC;    
  OUT.baseTCRnd.xy = (baseTC / 64.0) * g_VS_ScreenSize.xy + FrameRand.xy;
  
  return OUT;
}

vert2fragFog PreTransformedFogVS(app2vertFog IN)
{
	vert2fragFog OUT = (vert2fragFog)0;

  OUT.baseTC.xy = IN.Position.xy * float2(0.5, -0.5) + 0.5;
	OUT.CamVec.xyz = IN.CamVec.xyz;

	OUT.HPosition = IN.Position;
#if !D3D10 && !PS3
  OUT.HPosition.xy += 2 * float2(-g_VS_ScreenSize.z, g_VS_ScreenSize.w);
#endif  

	return OUT;
}

vert2frag TransformVS(app2vert IN)
{
  vert2frag OUT = (vert2frag)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);
  
  OUT.baseTC.xy = IN.baseTC.xy;

  return OUT;
}

pixout HDRBrightPassFilterPS(vert2frag IN)
{
  pixout OUT;
  
  half4 vSample;
  vSample = tex2D(baseMap, IN.baseTC.xy);

#if XENON
  // Using custom rgba16 integer format - set correct range [0, 32.0f[
  vSample *= 32.0f;
#endif

	// this way we check for NAN (illegal floats) as HLSL optimized the isnan() away
	// visible mostly on NVIDIA, if possible this should be removed and no shader should produce NAN
	  vSample.rgb = (vSample.rgb> 10000.0f)? half3(1, 1, 1): vSample.rgb;

// with abs() it might be more stable

	//if(abs(dot(vSample, 0.333)) > 10000.0f) vSample =1.0f;

		

#if !%_RT_HDR_HISTOGRAMM

  half fAdaptedLum = tex2D(lumMap1, float2(0.5f, 0.5f)).x;

  half Level = HDRParams0.w;
  half BrightOffset = HDRParams0.y;
  half BrightThreshold = HDRParams0.z;
  
	half fAdaptedLumDest = EyeAdaption(fAdaptedLum);		// RangeReducedAdaptedLum
  //fAdaptedLumDest =min(fAdaptedLumDest,1.0f);
	  
  // Determine what the pixel's value will be after tone-mapping occurs
   vSample.rgb *= Level/(fAdaptedLumDest + 0.001);
  
  // Subtract out dark pixels
  vSample.rgb -= BrightThreshold;
  
  // Clamp to 0
  vSample = max(vSample, (half4)0.0);
  
  // Map the resulting value into the 0 to 1 range. Higher values for
  // BRIGHT_PASS_OFFSET will isolate lights from illuminated scene 
  // objects.
   vSample.rgb /= (BrightOffset+vSample.rgb);

#else

  half Level = HDRParams0.w;

  vSample.rgb *= Level/(HDRParams0.z + 0.001);

#endif

  // We add lightshafts only on brightpass since it looks better/smoother than adding directly to HDRScene
   
  // will need encode/decode if quality < med
  half4 cLightShafts = ( tex2D(sceneMap2, IN.baseTC.xy) );
  
  // Use rgbs if fp16 filtering not supported
  #if !%BILINEAR_FP16  
    cLightShafts.xyz = DecodeRGBS( cLightShafts );  
  #endif     
       
  OUT.Color = vSample + cLightShafts / g_fBloomScale;
  
  // Store result in srgb space
  OUT.Color = LinearToSRGB( OUT.Color  );

  return OUT;
}

pixout HDRCalculateAdaptedLumPS(vert2frag IN)
{
  pixout OUT;
  
  half fAdaptedLum = tex2D(lumMap0, float2(0.5f, 0.5f)).x;
  half fCurrentLum = tex2D(lumMap1, float2(0.5f, 0.5f)).x;

#ifdef OPENGL
	if(isnan(fCurrentLum))
		fCurrentLum = 1.0f;
	if(isnan(fAdaptedLum))
		fAdaptedLum = 1.0f;
#else
	// this way we check for NAN (illegal floats) as HLSL optimized the isnan() away
	if(abs(fCurrentLum)>10000.0f)
		fCurrentLum=1.0f;
	if(abs(fAdaptedLum)>10000.0f)
		fAdaptedLum=1.0f;
#endif
 
  // The user's adapted luminance level is simulated by closing the gap between
  // adapted luminance and current luminance by 2% every frame, based on a
  // 30 fps rate. This is not an accurate model of human adaptation, which can
  // take longer than half an hour.
  //half fNewAdaptation = fAdaptedLum + (fCurrentLum - fAdaptedLum) * ( 1 - pow( 0.98f, 30 * ElapsedTime));
  
  half fNewAdaptation = fAdaptedLum + (fCurrentLum - fAdaptedLum) * ( 1 - pow( 0.98f, 100 * ElapsedTime));
		
  OUT.Color = float4(fNewAdaptation, fNewAdaptation, fNewAdaptation, 1.0f);

  return OUT;
}

pixout HDRSampleLumInitialPS(vert2frag IN)
{
  pixout OUT;
  
  half vSample = 0.0f;
  half fLogLumSum = 0.0f;
  int iSampleCount=9;

   // Compute the sum of log(luminance) throughout the sample points
  for(int i=0; i<iSampleCount; i++)
  {
    half3 cTex;
		cTex = tex2D(baseMap, IN.baseTC.xy+SampleOffsets[i].xy).rgb;

#if XENON
    // Using custom rgba16 integer format - set correct range [0, 32.0f[
    cTex *= 32.0f;
#endif

		vSample = dot(cTex.rgb, half3(0.2125f, 0.7154f, 0.0721f));
		fLogLumSum += vSample;
	} 

	//This changes save 8instructions (54 to 46)
//  OUT.Color = fLogLumSum;
  OUT.Color = min(fLogLumSum/(float)iSampleCount,64);

  return OUT;
}
pixout HDRSampleLumIterativePS(vert2frag IN)
{
  pixout OUT;
  
  half fResampleSum = 0.0f; 
  
  int nIter = 16;
#if %BILINEAR_FP16
  nIter = 4;
#endif    
  for(int i=0; i<nIter; i++)
  {
    // Compute the sum of luminance throughout the sample points
    half4 vTex = tex2D(baseMap, IN.baseTC.xy+SampleOffsets[i].xy);
    fResampleSum += vTex.x;
  }
  
  // Divide the sum to complete the average
  fResampleSum /= (float)nIter;

  OUT.Color = float4(fResampleSum, fResampleSum, fResampleSum, 1.0f);
  
  return OUT;
}

pixout HDRSampleLumFinalPS(vert2frag IN)
{
  pixout OUT;
  
  half fResampleSum = 0.0f;
  
  int nIter = 16;
#if %BILINEAR_FP16
  nIter = 4;
#endif    
  for(int i=0; i<nIter; i++)
  {
    // Compute the sum of luminance throughout the sample points
    half4 vTex = tex2D(baseMap, IN.baseTC.xy+SampleOffsets[i].xy);
    fResampleSum += vTex.x;
  }
  
  // Divide the sum to complete the average
  fResampleSum = fResampleSum/(float)nIter;
  
#ifdef XENON
    // Perform an exp() to complete the average luminance calculation
    //fResampleSum = exp(fResampleSum);
#endif

  OUT.Color = float4(fResampleSum, fResampleSum, fResampleSum, 1.0f);
  
  return OUT;
}

float colorChartWidthFixPS3 : PB_ColorCharts_WidthFixPS3;

void LookupColorChart(in sampler2D chartSampler, inout half3 cImage)
{
	const float chartDim = 16.0;
	
	//cImage = float3(0.5, 1.0, 4.0 / chartDim); // debug lookup color to test addressing of "unwrapped" chart slices
	
	// convert input color into 2d color chart lookup address 
	half3 scale = half3(chartDim - 1.0, chartDim - 1.0, chartDim - 1.0) / chartDim;
	half3 bias = half3(0.5, 0.5, 0.0) / chartDim;
	float3 lookup = saturate(cImage) * scale + bias;
	
#if PS3
	lookup.x *= colorChartWidthFixPS3;
#endif	
	
	half slice = lookup.z * chartDim;	
	half sliceFrac = frac(slice);	
	half sliceIdx = slice - sliceFrac;
	
	lookup.y = (lookup.y + sliceIdx) / chartDim;
	
 	// lookup adjacent slices
 	half3 col0 = tex2D(chartSampler, lookup.xy); 	
 	lookup.y += 1.0 / chartDim;
 	half3 col1 = tex2D(chartSampler, lookup.xy);

	// linearly blend between slices 	 	
	cImage = col0 + (col1 - col0) * sliceFrac;
		
 	//cImage = sliceFrac;
}

pixout HDRFinalScenePS(vert2frag IN)
{
  pixout OUT;
  
  // The per-color weighting to be used for luminance calculations in RGB order.
  half3 LUMINANCE_VECTOR  = float3 (0.2125f, 0.7154f, 0.0721f);

  half4 vSample = tex2D(baseMap, IN.baseTC.xy);
#if XENON
  //vSample = rgb10a2_to_rgb10a2f(vSample);
#endif

  half4 vScene = vSample;
  half4 cBloom = tex2D(bloomMap, IN.baseTC.xy);

  half fAdaptedLum = tex2D(lumMap, float2(0.5f, 0.5f)).x;
  
  half Level = HDRParams0.w;
  half BloomScale = g_fBloomScale;

  //float2 inTex = IN.baseTC.xy - 0.5;
  //float vignette  = 1 - dot(inTex, inTex);
  //vSample.rgb    *= saturate(pow(vignette, 4.0)+0.5);

#ifndef USE_EXP_TONEMAPPING

#if %_RT_HDR_HISTOGRAMM
  {
	// Ward94 tone mapping
	vSample.rgb *= 1/(HDRGamma.z + 0.001);  
	  
	// adjust gamma by the MidPercentil
	float fMidVal = (HDRGamma.y-HDRGamma.x)/(HDRGamma.z-HDRGamma.x);
	float fGamma = log(0.5f)/log(fMidVal);
	vSample.rgb = pow(vSample.rgb,fGamma);
  }
#else  

  // Reinhard with White Point
  {
  
	  {
			// todo: combine fTargetAvgLum into fAdaptedLumDest
  		const half fWhitePoint = 1.2;
			const half fTargetAvgLum = 0.22f;
	  
			const half fInvWhitePoint2 = 1.0f/(fWhitePoint*fWhitePoint);  

			half fAdaptedLumDest = EyeAdaption(fAdaptedLum);		// RangeReducedAdaptedLum
	  
			half fLum = dot(half4(vSample.rgb,1),half4(LUMINANCE_VECTOR,0.000001f));		// add small value to avoid division by 0

			half3 cBlackColor = float3(0.0f,0.0f,0.0f);
			half fBlackLevel=0;

		  vSample.rgb = lerp((0.5+0.5*tex2D(noiseMap,IN.baseTCRnd.xy).xyz) * (fLum+fBlackLevel) * half3(0.8f,0.8f,1.4f)*2.0f, vSample.rgb, saturate(5.0f*fLum));

			half Ls = fTargetAvgLum * fLum / fAdaptedLumDest;
			half Ld = Ls * (1+Ls*fInvWhitePoint2) / (1+Ls);
	  	
			vSample.rgb *= Ld/fLum;
		}

	  // desaturate
	  half fSaturation=0.8f;			// 1.0=full saturation, 0.0=grayscale
  	half fFinalLum = dot(vSample.rgb, LUMINANCE_VECTOR); 	
	 	vSample.rgb = lerp((half3)fFinalLum, vSample.rgb, fSaturation); 
	
		// contrast enhance
 		half fInvContrast = 1.15;		// 2.0 = contrast enhanced, 1.0=normal contrast, 0.01= max contrast reduced
		vSample.rgb = (vSample.rgb-0.5f)*fInvContrast+0.5f;	

	}
#endif

#endif
                  
    half fCenterDist = dot((IN.baseTC.xy*2-1), (IN.baseTC.xy*2-1));
    half fVignetting = saturate(1 - (fCenterDist - HDRParams2.z) * HDRParams2.w);

#ifdef USE_EXP_TONEMAPPING
	// custom exp tone mapper
	{		
//------------
		//same, but optimized version, saves 1 instruction
		half fLum = dot(vSample.rgb, LUMINANCE_VECTOR);
		half f = EyeAdaption( fAdaptedLum );

#if %_RT_SAMPLE1

    // blue shift for stocopic (dark) scenes

    // values hand tweaked for non-srgb rendering
    half fLumBlendMul = 5.0;                   
    half3 cBlueTarget = half3(0.8f,0.8f,1.4f);

#if %_RT_SAMPLE0
    // values hand tweaked for srgb rendering
    cBlueTarget = half3(0.6f,0.7f,1.0f);
    cBlueTarget = cBlueTarget * cBlueTarget;
   // fLumBlendMul *= fLumBlendMul;
    fLumBlendMul = 32;
#endif

    cBlueTarget *= fLum;
    vSample.rgb = lerp(cBlueTarget + tex2D(noiseMap,IN.baseTCRnd.xy).xyz * cBlueTarget, vSample.rgb, saturate(fLumBlendMul * fLum));

#endif

//------------

		// tone mapping

    // what are this values doing more exactly ?
		half fAdaptedLumDest = 3 / ( max( 0.1, 1 + 10 * EyeAdaption( fAdaptedLum ) ) );
	  		
    vSample.xyz = 1 - exp( -fAdaptedLumDest * fVignetting * vSample.xyz ); 

	}
#endif

  // Add bloom
  cBloom.xyz = DecodeRGBS( cBloom );  
  vSample.xyz += cBloom* BloomScale* (1-vSample.xyz) * fVignetting;

  // Perform color transformations. 
  //  - note: color transformations always in gamma space
  bool bSRGB = false;
#if %_RT_SAMPLE0
  bSRGB = true;
#endif

#if %_RT_SAMPLE3
  if( bSRGB )
    vSample.xyz = sqrt( vSample.xyz );

  // Apply color transformation matrix to ajust saturation/brightness/constrast  
  half4 tmpSample = half4(vSample.rgb, 1);

  // do a dp4 instead, saves 3 adds  
  //vSample.rgb = half3(	dot(tmpSample, HDRColorMatrix[0]), dot(tmpSample, HDRColorMatrix[1]), dot(tmpSample, HDRColorMatrix[2]) );
	LookupColorChart(colorChartMap, vSample.xyz);

  if( bSRGB )
    vSample.xyz *= vSample.xyz;
#endif

  OUT.Color = vSample;
 
  return OUT;
}

pixout HDRFinalDebugScenePS(vert2frag IN)
{
  pixout OUT;
  
  // The per-color weighting to be used for luminance calculations in RGB order.
  half3 LUMINANCE_VECTOR  = half3 (0.2125f, 0.7154f, 0.0721f);

  float4 sample = 0;
  for(int i=0; i<4; i++)
  {
    sample += tex2D(baseMap, IN.baseTC.xy + SampleOffsets[i].xy);
  }
  float4 vSample = tex2D(baseMap, IN.baseTC.xy);
  sample += vSample;
  
  //float fVal = dot(sample.xyz, half3(1,1,1));
  
  float4 s = 1;
  s.xyz = dot(vSample.xyz, LUMINANCE_VECTOR);
#ifdef OPENGL
	if (isnan(sample.x) || isnan(sample.y) || isnan(sample.z) || isnan(sample.w))
		s = half4(1, 0, 0, 0);
#else
//  if (isnan(sample.x))
//  if (!(sample.x>0 && sample.x<20000.0f))
  if (sample.x>10000 || sample.y>10000 || sample.z>10000)
		s = half4(1,0,0,0);
#endif

  if (sample.x<0 || sample.y<0 || sample.z<0)
		s=float4(0,1,0,1);

  OUT.Color = s;
  
  return OUT;
}

//===================================================================================

float3 volFogColorBase;
float3 volFogColorDelta;
float3 volFogColorGradient;

void FogPassCommon (in vert2fragFog IN, out float sceneDepth, out half4 localFogColor, out float3 worldPos, out float3 cameraToWorldPos)
{
  float2 sDepthRG;
#if XENON || PS3
	sDepthRG = GetLinearDepth(zMap, IN.baseTC.xy);
  sceneDepth = sDepthRG.x;
#else
  sDepthRG = tex2D(zMap, IN.baseTC.xy).rg;   
  sceneDepth = GetLinearDepth(sDepthRG.x);   
#endif

  cameraToWorldPos = sceneDepth * IN.CamVec.xyz;
  worldPos = cameraToWorldPos + vfViewPos.xyz;

#if %_RT_SAMPLE1
	half ang = saturate(normalize(IN.CamVec.xyz).z);
	localFogColor.xyz = half3(volFogColorDelta.xyz) * ang + half3(volFogColorBase.xyz);
	localFogColor.w = ComputeVolumetricFog(cameraToWorldPos);
#else
  localFogColor = GetVolumetricFogColor(worldPos, cameraToWorldPos, sceneDepth);
#endif  
  
#if %_RT_FSAA
  localFogColor.a = sDepthRG.y;
#endif
}

float2 fogDepthTestBlend;

pixout FogPassPS(vert2fragFog IN)
{
  pixout OUT;

#if %_RT_DEBUG0 && %_RT_DEBUG1 && %_RT_DEBUG2 && %_RT_DEBUG3
    OUT.Color = NumInstructions;
    return OUT;
#endif

	float sceneDepth;
	half4 localFogColor;
	float3 worldPos, cameraToWorldPos;

	FogPassCommon(IN, sceneDepth, localFogColor, worldPos, cameraToWorldPos);

	localFogColor.a = 1.0 - localFogColor.a;
#if %_RT_SAMPLE0
	localFogColor.a *= saturate(sceneDepth * fogDepthTestBlend.x + fogDepthTestBlend.y);
#endif  

#if PS3
  #if %_RT_HDR_MODE
    // PS3 HDR rendering is merging fog pass with scene hdr decode pass
    half4 cScene = DecodeRGBE( tex2D(sceneMap1, IN.baseTC.xy) );
    OUT.Color = lerp( cScene, localFogColor, localFogColor.w );
  #endif
#else

  HDROutput(OUT, localFogColor, 1);

#endif
  
  return OUT;
}

float4 LightningPos;				
float4 LightningColSize;
				
pixout FogPassWithLightningPS(vert2fragFog IN)
{
  pixout OUT;

#if %_RT_DEBUG0 && %_RT_DEBUG1 && %_RT_DEBUG2 && %_RT_DEBUG3
    OUT.Color = NumInstructions;
    return OUT;
#endif

	half sceneDepth;
	//half4 localFogColor;
	half3 worldPos, cameraToWorldPos;
	
	//FogPassCommon(IN, sceneDepth, localFogColor, worldPos, cameraToWorldPos);
	
  half2 sDepthRG = tex2D(zMap, IN.baseTC.xy).rg;
  sceneDepth = sDepthRG.x;   

  cameraToWorldPos = sceneDepth * IN.CamVec.xyz;
  worldPos = cameraToWorldPos + vfViewPos.xyz;
	

	/////////////////////////////////////////////////////////////
	// lightning computation... 
	// TODO: Optimize to fit into ps_2_0 limits!
	
	float atten = LightningColSize.w;	
	float3 c = atten * ( LightningPos.xyz - vfViewPos.xyz );
	float3 d = atten * cameraToWorldPos;
		
	float u = dot( c, c ) + 1;
	float v = -2 * dot( c, d );
	float w =  dot( d, d );
	float div = rsqrt( 4 * u * w - v * v );	
	//float lightning = sqrt( w ) * 2 * ( atan( ( v + 2 * w ) * div ) - atan( v * div ) ) * div; 
	float2 atan_res = atan( float2( v + 2 * w, v ) * div );
	float lightning = sqrt( w ) * 2 * ( atan_res.x - atan_res.y ) * div; 
    
  /////////////////////////////////////////////////////////////
	
  half4 Color = half4(LightningColSize.xyz * lightning, 1);
  
  HDROutput(OUT, Color, 1);
  
  return OUT;
}

pixout StretchHDRPS(vert2frag IN)
{
  pixout OUT;
  half4 sceneColor = tex2D(sceneMap0, IN.baseTC.xy);
  OUT.Color = sceneColor;
  return OUT;
}

pixout EncodeHDRPS(vert2frag IN)
{
  pixout OUT;
	  
  half4 sceneColor = tex2D(sceneMap0, IN.baseTC.xy);
  OUT.Color = HDREncode_ToLDR_RGBK(sceneColor);

  return OUT;
}

pixout Downscale4x4PS(vert2frag IN)
{
  pixout OUT;
  
  half4 sample = 0.0f;

  int nIter = 16;
  for(int i=0; i<nIter; i++)
  {
    float2 tc = IN.baseTC.xy + SampleOffsets[i].xy;
    sample.xyz += tex2D(sceneMap0, tc).xyz;
  }
      
  OUT.Color = sample / (float)nIter;
  
  return OUT;
}

pixout Downscale4x4_ToLDRPS(vert2frag IN)
{
  pixout OUT;
  
  half4 sample = 0.0f;

  int nIter = 16;
  for(int i=0; i<nIter; i++)
  {
    float2 tc = IN.baseTC.xy + SampleOffsets[i].xy;
    sample.xyz += tex2D(sceneMap0, tc).xyz;
  }
      
  OUT.Color = HDREncode_ToLDR_RGBK(sample / (float)nIter);
  
  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// ComposeFinalHDRGlow: compose final HDR glow into LDR glow texture //////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

struct vtxIn
{
  IN_P
  IN_TBASE
};

struct vtxOut
{
  float4 HPosition  : POSITION;
  float4 baseTC     : TEXCOORD0;
};

///////////////// vertex shader //////////////////

vtxOut BaseVS(vtxIn IN)
{
  vtxOut OUT = (vtxOut)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(vpMatrix, vPos);  
  OUT.baseTC.xy = IN.baseTC.xy;

  return OUT;
}

////////////////// samplers /////////////////////

pixout MergeBloomAndGlowPS(vtxOut IN)
{
  pixout OUT;
  
  half4 cBloom = tex2D( sceneMap0, IN.baseTC.xy );    
  half4 cGlow = tex2D( sceneMap1, IN.baseTC.xy );    

  OUT.Color = cBloom + (cGlow / g_fBloomScale);

  return OUT;
}

pixout ComposeFinalHDRGlowPS(vtxOut IN)
{
  pixout OUT;
  
  half4 map0 = SRGBtoLinear( tex2D( sceneMap0, IN.baseTC.xy) );    
  half4 map1 = SRGBtoLinear( tex2D( sceneMap1, IN.baseTC.xy) );    
  half4 map2 = SRGBtoLinear( tex2D( sceneMap2, IN.baseTC.xy) );   
  
  // 2.0, 1.15, 0.45 - handtweaked values to get nice sharp falloff
  //half4 cSum = ( map0 * 2.0 + map1 * 1.15 + map2 * 0.45 ); 
  half4 cSum = ( map0 + map1 + map2 ) ; 

  OUT.Color = EncodeRGBS( cSum );

  return OUT;
}

////////////////// technique /////////////////////

technique MergeBloomAndGlow
{
  pass p0
  {
    VertexShader = compile PROFILE_VS BaseVS();            
    PixelShader = compile PROFILE_PS MergeBloomAndGlowPS();
    CullMode = None;        
  }
}

technique ComposeFinalHDRGlow
{
  pass p0
  {
    VertexShader = compile PROFILE_VS BaseVS();            
    PixelShader = compile PROFILE_PS ComposeFinalHDRGlowPS();
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// DecodeIntoHDRTargetPS: decode encoded RT into HDRTarget ///////// //////////////////////////////

pixout DecodeIntoHDRTargetPS( vtxOut IN )
{
  pixout OUT;
	  
  // todo: profile merging this into fog pass (fog pass near clip optimization will be gone though)
  OUT.Color = DecodeRGBE( tex2D(sceneMap0, IN.baseTC.xy) );

  return OUT;
}

//=======================================================

struct app2vertLI
{
  float4 Position  : POSITION;
  float2 baseTC0    : TEXCOORD0;
  float3 baseTC1    : TEXCOORD1;
};

struct vert2fragLI
{
  float4 HPosition  : POSITION;
  float4 Info0      : TEXCOORD0;
  float4 Info1      : TEXCOORD1;
};

vert2fragLI LightInfoVS(app2vertLI IN)
{
  vert2fragLI OUT = (vert2fragLI)0; 

  // Position in screen space.
  float4 vPos = IN.Position;
  OUT.HPosition = vPos;
  OUT.Info0.xy = IN.baseTC0.xy;
  OUT.Info1.zw = IN.baseTC1.xy;
  
  return OUT;
}


pixout LightInfoPS(vert2fragLI IN)
{
  pixout OUT;
	  
  OUT.Color.xy = IN.Info0.xy;
  OUT.Color.zw = IN.Info1.xy;

  return OUT;
}


// HDR post-processing techniques

technique HDRSampleLumInitial
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRSampleLumInitialPS();
  }
}

technique HDRSampleLumIterative
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRSampleLumIterativePS();
  }
}

technique HDRSampleLumFinal
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRSampleLumFinalPS();
  }
}

technique HDRCalculateAdaptedLum
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRCalculateAdaptedLumPS();
  }
}

technique HDRBrightPassFilter
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRBrightPassFilterPS();
  }
}

technique HDRFinalPass
{
  pass p0
  {
    VertexShader = compile PROFILE_VS TransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRFinalScenePS();
  }
}

technique HDRFinalDebugPass
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS HDRFinalDebugScenePS();
  }
}

//======================================================================

technique FogPass
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedFogVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS FogPassPS();
  }
}

technique FogPassWithLightning
{
  pass p0
  {    
    VertexShader = compile PROFILE_VS PreTransformedFogVS();
    PixelShader = compile PROFILE_PS FogPassWithLightningPS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
  }
}

technique StretchHDR
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS StretchHDRPS();
  }
}


technique Encode_ToLDR
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS EncodeHDRPS();
  }
}

technique DecodeIntoHDRTarget
{
  pass p0
  {
    VertexShader = compile PROFILE_VS BaseVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS DecodeIntoHDRTargetPS();
  }
}

technique DownScale4x4
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS Downscale4x4PS();
  }
}

technique DownScale4x4_EncodeLDR
{
  pass p0
  {
    VertexShader = compile PROFILE_VS PreTransformedVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS Downscale4x4_ToLDRPS();
  }
}

technique LightInfo
{
  pass p0
  {
    VertexShader = compile PROFILE_VS LightInfoVS();
    
    ZEnable = false;
    ZWriteEnable = false;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS LightInfoPS();
  }
}

//======================================================================

struct vert2frag_zcullrecover
{
	float4 hPos : POSITION;
};

struct pixout_zcullrecover
{
	half4 col : COLOR0;

// Temporary workaround for RSX crash due to using MRT's but shader only outputting to 1 rt - seems we use only right combination with 1 frame delay 

#if %_RT_DEFERRED_SHADING || PS3
  half4 col1 : COLOR1;
#endif

  float  Depth  : DEPTH;
};

vert2frag_zcullrecover ZCullRecoverVS(app2vert IN)
{
	vert2frag_zcullrecover OUT = (vert2frag_zcullrecover) 0;
	OUT.hPos = float4(IN.Position.xy, 0.0001, 1);
	return OUT;
}

pixout_zcullrecover ZCullRecoverPS(vert2frag_zcullrecover IN)
{ 
	pixout_zcullrecover OUT=(pixout_zcullrecover)0;
	OUT.Depth	=	1.f;
  return OUT;
}

technique ZCullRecover
{
  pass p0
  {
    VertexShader = compile PROFILE_VS ZCullRecoverVS();
    
    ZEnable = true;
    ZWriteEnable = true;
    CullMode = None;
    
    PixelShader = compile PROFILE_PS ZCullRecoverPS();
  }
}

/////////////////////// eof ///
