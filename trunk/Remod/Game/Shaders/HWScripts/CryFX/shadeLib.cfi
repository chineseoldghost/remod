////////////////////////////////////////////////////////////////////////////
//
//  Crytek Engine Source File.
//  Shader extension
//  Copyright (C), Crytek Studios, 2001-2004.
// -------------------------------------------------------------------------
//  File name:   ShadeLib.cfi
//  Version:     v1.00
//  Created:     19/05/2006 by Tiago Sousa
//  Compilers:   
//  Description: Common BRDF's/shading utilities library
//
// -------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////

//==============================================================================
// Dynamic branching support

#if %DYN_BRANCHING
  LIGHTINFOMAP
  float4 LightInfoTC_DB : PB_LightInfoTC;
  int LightsNum_DB      : PB_LightsNum;

  #define SHADER_MODEL_VS vs_3_0
  #define SHADER_MODEL_PS ps_3_0
#else
 #define SHADER_MODEL_VS vs_Auto
 #define SHADER_MODEL_PS ps_Auto
#endif

// Common Samplers //////////////////////

DIFFUSEMAP
BUMPMAP
BUMPDIFFUSEMAP 
BUMPHEIGHTMAP
SHADOWOCCLUDEMAP
PROJECTIONCUBE
GLOSSMAP 
SCENEDEPTHMAP_POM
AMBIENTOCCLUSIONMAP


sampler2D detailMapSampler = sampler_state
{
  Texture = $Detail;
};


////////////////////////////////////////////////////////////////////////////////////////////////////

#define REFLECT_OFF    0
#define REFLECT_CUBE   1
#define REFLECT_SPHERE 2

//////////////////////////////// Shared fragment-shading pass structure /////////////////////////////////////

struct fragInput
{
  //===============================================================================
  // input attribute data
  float4 baseTC;
  float4 basesectorTC;
  float4 bumpTC;
  float4 terrainDetailTC;
  
  float4 vTangent;
  float4 vBinormal;
  float4 vNormal;
  float4 vView;
  
  float4 screenProj;
  float4 projTC;
  
  float4 Color;
  float4 Color1;
  float4 VisTerrainCol;
  float4 SunRefl;
  float4 Ambient;

  half4 AlphaTest;
  
  float3 DistAtten;
  float4 AvgFogVolumeContrib;
  
  float4 OutdoorAOInfo;
};

struct fragPass
{
  fragInput IN;

  // Usage flags fo shared stuff  
  bool bCustomComposition;      // dont use shared final shading composition
  bool bRenormalizeNormal;
	bool bForceRenormalizeNormal;
  bool bDontUseBump;
  bool bDiffuseBump;
  bool bDetailBumpMapping;
  bool bDetailBumpMappingMasking;
  bool bOffsetBumpMapping;
  bool bWorldSpaceBumpMapping;
  bool bParallaxOcclusionMapping;  
  bool bVertexColors;      // apply vertex color to final result
  bool bAlphaGlow;         // use diffuse texture alpha has glow
  bool bViewDependentAmbient;
  bool bHemisphereLighting;
  bool bDontUseEmissive;
  bool bRefractionMap; 
  bool bTerrainPass;  
  bool bDisableInShadowShading;  
  bool bDisableAlphaTestD3D10; 
  int  nReflectionMapping; // reflection mapping type (0: off, 1: cube map, 2: spherical)
  half fBumpHeightScale;
  half fSelfShadowStrength;
  
  half2 vDetailBumpTilling; // detail diffuse_bump mapping tilling
  half fDetailBlendAmount;	// detail blend amount
  half fDetailBumpScale; 	 // detail bump mapping scale
  
  half fLod;		 					 // lod scale: 1 max, 0 disabled
  
  // shared fields
  int nQuality;           // shader quality level
  
  float3x3 mTangentToWS;  // tangent to world space transformation matrix - might be required for some vectors
  half3 vView;           // eye vector, fFogFrac
  half3 vNormal;         // normal vector
  half3 vNormalDiffuse;  // diffuse normal vector
  half3 vReflVec;        // reflection vector
          
  half3 cBumpMap;        // tangent space normal map
  half4 cDiffuseMap;     // diffuse map
  half4 cGlossMap;       // specular/gloss map
  half3 cEnvironment;    // environment map
  half4 cShadowOcclMap;  // shadow map

  half fNdotE;           // per pass constant NdotE
  half fSpecPow;         // specular power
  half fAlpha;           // opacity   
  half fAlphaTestRef;    // instanced alpha test value
  half cAOMapVal;        // value from AO target
      
  // Note: parser bug, assumes fReflectionAmount, fFresnelBias, etc, are same as tweakable parameters, therefore the _ was added
  
  half fReflection_Amount;  // amount of reflection  
  half fFresnel_Bias;     // fresnel biasing
  half fFresnel_Scale;    // fresnel scale
  half fFresnel;         // final fresnel term
  
  half fAlphaGlow_Multiplier;   // apply multiplier to diffuse alpha glow 
  
  // Shading accumulation
  
  half3 cAmbientAcc;
  half3 cDiffuseAcc;
  half3 cSpecularAcc;

  // Custom per pass data   
  fragPassCustom pCustom;
};
  
struct fragLightPass
{
  int nType;          // light type
  half3 cDiffuse;    // light diffuse color
  half3 cSpecular;   // light specular color
  half3 cFilter;     // light filter color
  half3 vLight;      // light vector
    
  half fNdotL;       // normal dot light
  half fFallOff;     // light attenuation  
  half fOcclShadow;  // light shadow term
  
  half3 cOut;        // light final contribution  

  // ... Custom per light data ...
  fragLightPassCustom pCustom;
}; 


//////////////////////////////// Common shading utilities ////////////////


#define PI 3.1415
#define PI_X2 6.2831
#define PI_X4 12.5663
#define NEPPER 2.7183

half3 ModifyAmbient(half3 ambient, half bumpZ, half bias)
{
  return (ambient * ( saturate( bumpZ ) + bias ) );
}

// assumes 0 is min
half smoothstep_opt(in half maxi, in half x)
{
  x = saturate( x / maxi );
  return  x * x  * (3.0 - 2.0 * x);
}

sampler2D smoothstepMapSampler = sampler_state
{
  Texture = textures/defaults/smoothstep_sampler.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

// assumes 0 is min, and max <= 1.0
half smoothstep_opt_tex(in half maxi, in half x)
{
#if D3D10
  return tex2Dlod( smoothstepMapSampler, float4(maxi, x, 0, 0) ).w;
#else
  return tex2D( smoothstepMapSampler, float2(maxi, x) ).w;
#endif

}

half GetFresnel(half NdotI, half bias, half power)
{
  half facing = (1.0 - NdotI);
  return bias + (1-bias)*pow(facing, power);
}

half GetFresnelOpt(half NdotI, half bias, half power)
{
  half facing = (1.0 - NdotI);
  return bias + pow(facing, power);  // opt: removed (1-bias) mul
}

sampler2D fresnelShlickMapSampler = sampler_state
{
  Texture = textures/defaults/fresnel_sampler.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

// Cheap shlick fresnel term using lookup table (each channel has a diferent power (x = 1,  y = 2, z = 4, w = 5) )
half4 GetFresnelTex( float NdotI, float bias)
{

#if D3D10
  return tex2Dlod( fresnelShlickMapSampler, float4(NdotI, bias, 0, 0) );
#else
  return tex2D( fresnelShlickMapSampler, float2(NdotI, bias) );
#endif

}

half GetRim( in half NdotL, in half NdotH, in half fresnel, in half power, in half multiplier)
{    
  half kr = smoothstep_opt(0.5, fresnel) * multiplier;
  return kr * NdotL * pow(NdotH, power);
} 

half GetRimTex( in half NdotL, in half NdotH, in half fresnel, in half power, in half multiplier)
{        
  half kr = smoothstep_opt_tex(0.5, fresnel) * multiplier;
  return kr * NdotL * pow(NdotH, power);  
  // 4 ALU and 1 TEX
} 

half GetAttenuation(half3 L, half fInvRadius)
{
  half3 vDist = L * fInvRadius;
  half fFallOff = saturate(1-dot(vDist, vDist));

  return fFallOff;
}

half3 NormalToWorldSpace(half3 N, half3x3 mMatrix)
{
  half3 wsN = mul(N, mMatrix);
  wsN = normalize(wsN);
  return wsN;
}

half3 ShiftVector(half3 V, half3 N, half shiftAmount)
{
  return normalize(V + shiftAmount * N);
  // 3 alu, 1 mad
}

// optimized shift vector - skips normalization - use only when vector lenght not relevant
half3 ShiftVectorOpt(half3 V, half3 N, half shiftAmount)
{
  return (V + shiftAmount * N);
  // 1 mad
}

// dot unnormalized vectors 
//  - beware that only in some cases this technique might be a win
half dot_opt(half3 A, half3 B)
{
  // compiler should optimize redundant/repeated computations away
  half AdotA = dot(A, A);                                                                          // 1 dot
  half BdotB = dot(B, B);                                                                          // 1 dot
  
  return dot(A, B) * rsqrt( AdotA * BdotB );                                                        // 1 dot, 3 alu
  
  // 4 alu average 
}

// assumes base in 0..1 range
float pow_schlick( float a, float exponent)
{
  return (1.0 / exponent) * (a - 1.0) + 1.0;    
}

//////////////////////////////// Color/blending processing ////////////////////////////////

// Compute color luminosity
float ColorLuminosity( half3 cColor )
{
  const half3 cParams = half3( 0.33, 0.59, 0.11 );
  return dot( cColor, cParams );                                                                    // 1 alu
}

// Adjust color contrast
half3 ColorContrast( half3 cColor, half fAmount)
{
   //return max( (0.5 - 0.5 * fAmount) + cColor * fAmount, 0.0);                                        // 2 alu
   return max( lerp(0.5, cColor, fAmount), 0.0 );                                        // 2 alu
}

// Adjusts color saturation
half3 ColorSaturation( half3 cColor, half fAmount)
{
   return lerp( ColorLuminosity(cColor), cColor, fAmount);                                          // should be 2 alu
}

// Adjusts color brightness
half3 ColorBrightness( half3 cColor, half fAmount)
{
   return cColor * fAmount;                                                                         // 1 alu
}

float4 BlendDarken( float4 c1, float4 c2)
{
  return (c1 <  c2)? c1 : c2;					                                          // 1 alu
}

float4 BlendDiference( float4 c1, float4 c2)
{
  return abs(c1 -  c2);													                                          // 2 alu
}

float4 BlendScreen( float4 c1, float4 c2)
{
  return c1 +  c2 * ( 1.0 - c1);													                            // 2 alu
}

float4 BlendOverlay( float4 c1, float4 c2)
{
  return (c1 < 0.5f)? 2.0 * c1 * c2 : -1.0 + 2.0 * BlendScreen(c1, c2);	  // 5 alu
}

//////////////////////////////// Common HDR encoding/decoding ////////////////////////////////

#define MAX_FLOAT 128.0

// Using PPP format
// quality: bad with big maximum
float4 EncodePPP( float4 cColor )
{  
  float fInvMax = 1.0 / MAX_FLOAT;  
  return float4(pow( cColor.xyz * fInvMax,  0.25 ), 1);
}
 
float3 DecodePPP( float4 cColor )
{  
  float fInvPowFactor = 1.0 / 0.25;   
  return MAX_FLOAT * pow(cColor.xyz, fInvPowFactor);
}

// Using EEE format (similar to rgbe, but in rgb instead)
// quality: good (although some visible banding), filtering doable
float4 EncodeEEE( float4 cColor )
{  
  float fHDR_EXP_BASE = 1.04;
  float fHDR_EXP_OFFSET = 128.0;

  float3 cExp = log(cColor.xyz) / log(fHDR_EXP_BASE);

  return float4((cExp + fHDR_EXP_OFFSET) / 255.0, 1);
}

// Using EEE format (similar to rgbe, but in rgb instead)
// quality: good (although some visible banding), filtering doable 
float4 DecodeEEE( float4 cColor )
{  
  float fHDR_EXP_BASE = 1.04;
  float fHDR_EXP_OFFSET = 128.0;

  half3 cExp = cColor.xyz * 255.0 - fHDR_EXP_OFFSET;
  return float4( pow(fHDR_EXP_BASE, cExp), 1 );
}

// Using RGBS + PPP(scale value stored in alpha - filtering should decode first) 
// quality: very good
float4 EncodeRGBS( float4 cColor )
{  
  float fInvMaxValue = 1.0 / MAX_FLOAT;

  //cColor.xyz = min(cColor.xyz, MAX_FLOAT);

  // remove fractional part (to avoid artefacts) 
  float fMax = ceil(( max(cColor.x, max( cColor.y, cColor.z ) ) ));
  
  float4 ret = 0;    
  ret.xyz = (cColor.xyz / (fMax));    
  ret.w = fMax * fInvMaxValue;  
  
  //ret.w *= rsqrt( ret.w );        
  //ret.xyz *= ret.w;
  
  ret.xyz *= rsqrt( ret );

  return (ret);
}

// Using RGBS format (scale value stored in alpha)
// quality: very good
float4 DecodeRGBS( float4 cColor )
{     
  return float4( MAX_FLOAT * cColor.xyz * cColor.w * cColor.xyz, 1) ;  
}

// Using RGBE format (exponent in alpha- filtering should decode first)
// quality: perfect
float4 EncodeRGBE( in float3 color )
{  
  float fHDR_EXP_BASE = 1.06;
  float fHDR_EXP_OFFSET = 128.0;

  //half fLen = dot(color.xyz, 1.0);  
  float fLen = max( color.x, max( color.y, color.z ) ) ;  
  //half fExp = ( log(fLen) / log(fHDR_EXP_BASE) );
  half fExp = ceil( log(fLen) / log(fHDR_EXP_BASE) );

  half4 ret;
  ret.w = (fExp + fHDR_EXP_OFFSET) / 256;
  ret.xyz = color.xyz / pow( fHDR_EXP_BASE, fExp);

  return ret;   
}

// Using RGBE format (exponent in alpha- filtering should decode first)
// quality: perfect
float4 DecodeRGBE( in float4 rgbe )
{ 
  float fHDR_EXP_BASE = 1.06;
  float fHDR_EXP_OFFSET = 128.0;

  half fExp = rgbe.w * 256 - fHDR_EXP_OFFSET;
  half fScale = pow(fHDR_EXP_BASE, fExp);

  return float4( rgbe.xyz * fScale, 1);  
}

// Using RGBE format (exponent in alpha - filtering should decode first)
// quality: perfect
float4 EncodeRGBECorrected( in float3 color )
{  

  float fMaxChannel = max( color.x, max( color.y, color.z ) ) ;    
  float fExp = ceil( log2( fMaxChannel ) );
  
  float4 ret = 0;
  ret.xyz = color.xyz / exp2( fExp );  
  ret.w = ( fExp + 128.0 ) / 256.0;
  
  return ret;
}

// Using RGBE format (exponent in alpha - filtering should decode first)
// quality: perfect
float4 DecodeRGBECorrected( in float4 rgbe )
{   
  return float4( rgbe.xyz * exp2( rgbe.w * 256.0 - 128.0), 1 );
}

//////////////////////////////// Common Brdfs ////////////////////////////////
// Note that functions with Tex suffix use optimized code with texture lookups 
// else functions use pure math.

//////////////////////////////// Blinn model ///////////////////////////////
// - Blinn has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.

half Blinn(half3 N, half3 V, half3 L, half Exp)
{ 
  half3 H = normalize( V + L );				// 4 alu
  return pow( saturate( dot(N, H) ) ,  Exp);	// 4 alu
  
  // 8 ALU
}

//////////////////////////////// Anisotropic blinn model ///////////////////////////////
// - Blinn anisotropic model has good properties for generic anisotropic highlights 
// (can have radial or disk shape)
// - Very cheap

half BlinnAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{   
  half3 H = ( V + L ) * 0.5;				                                                                // 2 alu
  half2 HdotT_B = half2( dot(H, B), dot(H, T) ) * vSurfaceRoughness.xy;                           // 3 alu
    
  //return pow( sqrt(saturate( 1 - HdotT_B.x * HdotT_B.x - HdotT_B.y * HdotT_B.y) ), Exp);            // 4 alu + 3 alu  
  
  // merged sqrt with pow -> sqrt<=> pow( scalar, 0.5)  -> pow(sqrt(scalar), exp) <=> pow(scalar, exp * 0.5 )

  return pow( saturate( 1 - dot(HdotT_B.xy, HdotT_B.xy) ), 0.5 * Exp);            // 4 alu
  
  // about 12 ALU
}

sampler2D blinnAnisotropicSampler = sampler_state
{
  Texture = textures/defaults/blinn_anisotropic_sampler.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half BlinnAnisotropicTex(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{   
  half3 H = ( V + L ) * 0.5;				                                                                // 2 alu
  float2 HdotT_B = float2( dot(H, B), dot(H, T) ) * vSurfaceRoughness.xy;                           // 3 alu
  
  const float4 cDecompressD = float4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * 32.0;
  float fAnisoDistribution = dot( tex2D( blinnAnisotropicSampler, HdotT_B * 0.5 + 0.5).xyzw, cDecompressD.xyzw ); // 1 texl, 1 alu
    
  return pow( fAnisoDistribution, Exp);                         // 3 alu  
  
  // about 9 ALU
}

//////////////////////////////// Phong model /////////////////////////////////////
// - Phong model has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.

half Phong(half3 N, half3 V, half3 L, half Exp)
{
  half3 R = reflect(-L, N);					// 3 ALU
  return pow( saturate( dot(V, R) ) ,  Exp);	// 4
  
  // 7 ALU
}

// Optimized phong, use if mirrowed reflection vector pre-computed
half Phong(half3 R, half3 L, half Exp)
{	
  return pow( saturate( dot(L, R) ) ,  Exp); //4
  // 4 ALU
}

//////////////////////////////// Cook-Torrance model ////////////////////////
// - Cook-Torrance model has very good properties for metallic surfaces
// - Pure math versions are expensive.

// Pre-computed cook-torrance D term using a FP32 texture

// todo: use FP16 instead (needs loading support also..)
sampler2D cookTorranceDSampler = sampler_state
{ 
  Texture = textures/defaults/cook_d_sampler_g16r16f.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half GetBeckchamDistribution(half NdotH, half m)
{
  // Compute Beckcham distribution function (D term)
  half  NdotH_pow2 = NdotH * NdotH;                                                              // 1 mul
  half  m2_mul_NdotH_pow2 = m * m * NdotH_pow2;                                                  // 2 alu
  half  tanDelta = ( 1.0 - NdotH_pow2 ) / ( m2_mul_NdotH_pow2 );                                 // 2 alu
  return exp( -tanDelta ) / ( m2_mul_NdotH_pow2 * NdotH_pow2  + 0.001);	                        // 3 alu
  // 8 ALU
}

float GetBeckchamDistributionTex(float NdotH, float m)
{
#if D3D10
  return tex2Dlod( cookTorranceDSampler, float4(NdotH, m, 0, 0) ).x;
#else
  return tex2D( cookTorranceDSampler, float2(NdotH, m) ).x;
#endif
}

half CookTorrance(half3 N, half3 V, half3 L, half fFresnelBias, half m)
{
  // Compute half vector and coeficients
  half3 H = normalize( V + L );								    							    // 1 add, 1 nrm	
  half NdotL = dot( N, L );																		// 1 dot			
  half VdotH = dot( V, H );																		// 1 dot
  half NdotE = dot( N, V );																		// 1 dot	
  half NdotH = dot( N, H );								    									// 1 dot
  half fFresnel = GetFresnelTex(NdotE, fFresnelBias).w;											// 1 texl

  // Compute Beckcham distribution function (D term)
  half  D = GetBeckchamDistribution(NdotH, m);
  
  // Compute geometric attenuation (G term)
  float NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  float G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;					// 1 mins, 1 mul  

  // Cook-torrance specular term
  return D * G * fFresnel/ (PI * NdotL * (NdotE + 0.01));											// 1 div, 5 muls			
  
  // aprox 26 ALU, 1 TEX
}

// Cheaper version, with pre-computed NdotE and NdotL term. Assuming Fresnel and PI*NdotL term constant 1.0

half CookTorrance(half3 N, half3 V, half3 L, half NdotE, half NdotL, half m)
{
  // Compute half vector and coeficients
  half3 H = normalize( V + L );								    							    // 1 add, 1 nrm	
  half VdotH= dot( V, H );																		// 1 dot	
  half NdotH = dot(N, H);								    									// 1 dot
  
  // Compute Beckcham distribution function (D term)
  half  D = GetBeckchamDistribution(NdotH, m);    
  // Compute geometric attenuation (G term)
  half NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  float G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;					// 1 mins, 1 mul  

  // Cook-torrance specular term
  return D * G  / (NdotE + 0.01);																			// 1 div, 1 mul
  
  // aprox 18 ALU
}

half CookTorranceTex(half3 N, half3 V, half3 L, half NdotL, float m)
{			
  // Compute half vector and coeficients

  half3 H = normalize( V + L );																	// 1 add, 1 nrm	
  half VdotH = dot( V, H );																		// 1 dot	
  half NdotE = dot( N, V );																		// 1 dot	
  float NdotH = dot( N, H );															    		// 1 dot
    
  // Compute Beckcham distribution function (D term)
  float D = GetBeckchamDistributionTex(NdotH, m);
  
  // Compute geometric attenuation (G term)
  half NdotH_div_VdotH = 2 * NdotH / saturate(VdotH);												// 1 mul, 1 div    
  half G = saturate( min( NdotH_div_VdotH * NdotE, NdotH_div_VdotH * NdotL) ) ;                  // 1 mins, 1 mul  

  return D * G / (NdotE + 0.01);
  
  // aprox 12 ALU, 1 TEX
}

// A bit optimized version, with pre-computed NdotE for all lights and NdotL

half CookTorranceTex(half3 N, half3 V, half3 L, half NdotE, half NdotL, half m)
{
  // Compute half vector and coeficients	

  half3 H = normalize( V + L );																	// 4 alu
  half VdotH = dot( V, H );																		// 1 dot
  half NdotH = dot( N, H );																		// 1 dot

  // Compute Beckcham distribution function (D term)
  half D = GetBeckchamDistributionTex(NdotH, m);    // 1 alu
  
  // Compute geometric attenuation (G term)																									
  half NdotH_div_VdotH = 2 * NdotH / VdotH;/// max(VdotH, 0.01);												// 2 alu
  half G =  saturate( NdotH_div_VdotH *min( NdotE, NdotL) ) ;					// 2 alu

    // assume NdotE and Fresnel = 1
  return D * G/ max(NdotE, 0.001);  // 4

  // aprox 15 ALU
}

//////////////////////////////// Ward model, anisotropic /////////////////////////
// - Ward anisotropic model has good properties for generic anisotropic highlights 
// (can have radial or disk shape)
// - Pure math versions are expensive

half WardAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half2 vSurfaceRoughness, half Exp)
{
  half3 H = normalize( V + L );																	                                  // 1 add, 1 nrm	- 4 alu sum
  half NdotL = saturate( dot( N, L ) );															// 1 dot	
  half NdotE = saturate( dot( N, V ) );															// 1 dot
  half NdotH = dot( N, H );																		// 1 dot

                                    
  half2 HdotT_B = half2( dot( H, B ), dot( H, T ) ) / vSurfaceRoughness.xy;						// 2 dots, 1 div
  HdotT_B *= HdotT_B;																				// 1 mul

  half specK = saturate( rsqrt( NdotL * NdotE ) );													                        //  1 rcp, 1 mul
  specK *= NdotL * exp((-2.0 * (HdotT_B.x + HdotT_B.y))/(1.0 + NdotH));							// 7 alu
             
  return pow(specK, Exp);																			// 1 pow - 3 alu

  // aprox 23 ALU
}

// A bit cheaper version with NdotL and NdotE pre-computed

half WardAnisotropic(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  half3 H = normalize( V + L );																	                                  // 1 add, 1 nrm	 - 4 alu sum
  half NdotH = dot( N, H ) ;																		                                    // 1 dot	
                                        
  half2 HdotT_B = half2( dot( H, B ), dot( H, T ) ) / vSurfaceRoughness.xy;						            // 2 dots, 1 div
  HdotT_B *= HdotT_B;																				                                        // 1 mul

  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( NdotL * NdotE ) );												                          // 1 rcp, 1 div
  specK *= NdotL * exp((-2.0 * (HdotT_B.x + HdotT_B.y))/(1.0 + NdotH));							                // 7 alu
             
  return pow(specK, Exp);																			                                      // 1 pow - 3 alu

  // aprox 21 ALU
}

sampler2D anisExpSampler = sampler_state
{ 
  Texture = textures/defaults/anis_exp_sampler.dds;
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;
};

half GetAnisoDistributionTex(half NdotVec, half s)
{
  const float4 cDecompressD = float4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * 32.0;	
#if D3D10
  return dot( tex2Dlod( anisExpSampler, float4(NdotVec, s, 0, 0) ), cDecompressD );	
#else
  return dot( tex2D( anisExpSampler, float2(NdotVec, s) ), cDecompressD );	
#endif
  // 1 tex, 1 dot
}

// Note: Assumes surface roughness divided by 10.0 - for a bit extra precision on texture lookup
half WardAnisotropicTex(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  // opt: averaging vectors instead of normalization
  half3 H = 0.5 *( V + L );																	                                      // 1 add, 1 mul
  
  half NdotH = dot( N, H );	  									                                                  // 1 dot
                                        
  float2 HdotT_B = (abs( half2( dot( H, B ), dot( H, T ) ) *( vSurfaceRoughness.xy)));               // 2 dots, 1 div, 1 abs
  half2 vExpDist;
  vExpDist.x = GetAnisoDistributionTex( HdotT_B.x, NdotH );                                         // 1 tex, 1 dot
  vExpDist.y = GetAnisoDistributionTex( HdotT_B.y, NdotH );                                         // 1 tex, 1 dot
   
  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( saturate( NdotL * NdotE ) ) );			  	                          // 1 rcp, 1 mul
  specK *= NdotL * vExpDist.x * vExpDist.y;                                                         // 3 muls
                 
  return pow(specK, max(Exp, 0.0001)); 	 // # temporary solution #
  
  // 18 alu  
}

half WardAnisotropic_opt(half3 T, half3 B, half3 N, half3 V, half3 L, half NdotL, half NdotE, half2 vSurfaceRoughness, half Exp)
{
  // opt: averaging vectors instead of normalization
  //half3 H =  (V + L)*  0.5;                                        // 1 alu
  half3 H =  normalize(V + L);                                        // 1 alu


  half NdotH = dot( N, H );                                                    // 1 alu

  float2 HdotT_B = ( half2( dot( H, B ), dot( H, T ) ) )* vSurfaceRoughness.xy;                 // 3 alu
  HdotT_B *= HdotT_B;                                                                             // 1 alu

  // using sat instead, since it's free, but compensating by brighting specular
  half specK = saturate( rsqrt( saturate( NdotL * NdotE ) ) );                                 // 2 alu

  // opt: merged exponential with power factor
  //specK *= NdotL * exp( Exp* (-2.0 * (HdotT_B.x + HdotT_B.y) )/(1.001 + NdotH) );  // 6 alu
  specK *= NdotL * exp( dot(HdotT_B.xy, -2.0 * Exp/(1.001 + NdotH)) );  // 6 alu

  return specK;

  // 14 alu  
}

//////////////////////////////// Banks model, anisotropic /////////////////////////
// - Banks anisotropic model has Good properties for disk shape anisotropic 
// highlights (good for metallic surfaces)
// - Very cheap

half BanksAnisotropic(half3 T, half3 V, half3 L, half Exp)	
{
    half LdotT = dot( L, T );																		// 1 dot
    half VdotT = dot( V, T );																		// 1 dot
        
    half fSpec = sqrt( 1 - LdotT * LdotT );														// 1 mad, 1 rcp		
    fSpec *= sqrt( 1 - VdotT * VdotT );																// 1 mul, 1 mad, 1 rcp
    fSpec = saturate( fSpec - LdotT * VdotT );
      
  return pow(fSpec, Exp);																			// 1 pow
  
  // aprox 8 ALU
}

half BanksAnisotropicTex(half3 T, half3 V, half3 L, half Exp)	
{
  // Todo
  
  return 1;
  
  // 1 ALU, 1 TEX
}

//////////////////////////////// Kajiya-Kay model, anisotropic /////////////////////////
// - Kajiya-Kay anisotropic model has Good properties for radial shape anisotropic 
// highlights (good for hair)
// - Very cheap

half KajiyaKayAnisotropic(half3 T, half3 V, half3 L, half Exp)
{
  half3 H = normalize( V + L );																// 4 alu
  half TdotH = dot( T, H );																		// 1 dot
  
  half fSpec = sqrt( max( 1.0 - TdotH * TdotH, 0.01) );										// 1 mad, 1 sqrt
  
  return pow( fSpec, Exp );																	  	// 3 alu
  
  // aprox 10 ALU
}

// A bit cheaper version, half vector already pre-computed
half KajiyaKayAnisotropic(half3 T, half3 H, half Exp)
{	
  half TdotH = dot( T, H );																  // 1 dot	
  half fSpec = sqrt( max( 1.0 - TdotH * TdotH, 0.01) );							    // 1 mad, 1 sqrt
  
  return pow( fSpec, Exp );																		// 3 alu
  
  // aprox 6 ALU		
}

//////////////////////////////// Kajiya-Kay model, anisotropic /////////////////////////
// - Oren-Nayar model has good properties for very rough surfaces (eg: sand, paper, cloth). 
// - Expensive

half OrenNayar(half3 N, half3 V, half3 L, half Exp)
{

  // Todo
  
  return 1;

}

half OrenNayarTex(half3 N, half3 V, half3 L, half Exp)
{

  // Todo
  
  return 1;

}
//////////////////////////////// Vegetation shading ////////////////

// Common vegetation shading

half3 LeafShadingBack(half3 vEye, half3 vLight, half3 vNormal, half3 cDiffBackK, half backViewDep)
{            
  half EdotL=saturate(dot(vEye.xyz, -vLight.xyz));          
  
  // Tweaked NdotL wrapping - Artists request
  half fLdotNBack=saturate(dot(vNormal.xyz, vLight.xyz)*0.6+0.4);

  half powEdotL = EdotL*EdotL;
  powEdotL *= powEdotL;
    
  half3 vBackShading = saturate(powEdotL*backViewDep + (1.0-backViewDep) * fLdotNBack);    

  return vBackShading * cDiffBackK.xyz;
}   

void LeafShadingFront(half3 vEye, half3 vLight, half3 vNormal, half3 cDifK, half3 cSpecK, inout half3 outDif, inout half3 outSpec, half fSpecularExp)
{                                                                                                                                  
  half fLdotNFront=dot(vNormal.xyz, vLight.xyz);      
  // Compute front diffuse term  
#if %GRASS   
  outDif=max(fLdotNFront, 0.5)*cDifK.xyz; 
#else
  outDif=saturate(fLdotNFront)*cDifK.xyz;
#endif
  // compute specular if necessary 
#if !%GRASS
  outSpec= Phong(vEye, vLight, fSpecularExp) * cSpecK.xyz;  
#endif
}

// Common SH vegetation shading

//simple sin approx for 2 at a time
float2 ApproxSine2(float2 arg)
{ 
  #define PI 3.14159265
  float2 x = frac(arg/(2.0*PI)+0.5)*2.0*PI-PI;//brings into -pi..pi, same instr. generated as for sincos
  float2 x3 = x * x * x;  //cubic component
  float a = -8.0/(3*PI*PI*PI);	//constant
  float c = 8.0/(3*PI);			//constant
  return (a*x3 + c*x); //4 at once, how fast can it get...
}

//simple sin approx for 4 at a time
float4 ApproxSine4(float4 arg)
{ 
  #define PI 3.14159265
  float4 x = frac(arg/(2.0*PI)+0.5)*2.0*PI-PI;//brings into -pi..pi, same instr. generated as for sincos
  float4 x3 = x * x * x;  //cubic component
  float a = -8.0/(3*PI*PI*PI);	//constant
  float c = 8.0/(3*PI);			//constant
  return (a*x3 + c*x); //4 at once, how fast can it get...
}

float DoSHLookup(float3 vDir, float4 SHShadowing[2])
{
  float4 tempSH0 = float4(vDir,1);//use normalized object space light vector as query input
  float2 tempSH1 = float2(dot(tempSH0, SHShadowing[0]),0);
  float4 tempSH3 = tempSH0.xyzz * tempSH0.yzzx;
  tempSH0.xy *= tempSH0.xy;
  tempSH3.x = tempSH0.x - tempSH0.y;
  tempSH1.y = dot(tempSH3, SHShadowing[1]);
  return (tempSH1.x + tempSH1.y);
}

//============================================================================================



float2 ParallaxOcclusionMap(in float2 baseTC, in float lod, in float3 viewDirNrm, in int numSteps, in float displacement)
{
	float step =  1.0 / numSteps;
	float bumpScale = displacement;
	
	float2 delta = float2(viewDirNrm.x, viewDirNrm.y) * bumpScale / (-viewDirNrm.z * numSteps); // / max(-viewDirNrm.z * numSteps, 0.1)
		
	float4 NB0 = tex2D(bumpHeightMapSampler, baseTC);
			
	float height = 1 - step;
	float4 offset = float4(baseTC + delta, 0, lod);
	float4 NB1 = tex2D(bumpHeightMapSampler, offset);

	for (int i=0; i<numSteps; i++)
	{
		[flatten]
		if (NB1.w >= height)
			break;
			
		NB0 = NB1;

		height -= step;
		offset.xy += delta;

		NB1 = tex2Dlod(bumpHeightMapSampler, offset);
	}
	
	float4 offsetBest = offset;
	float error = 1.0;

	float t1 = height;
	float t0 = t1 + step;
	
	float delta1 = t1 - NB1.w;
	float delta0 = t0 - NB0.w;

	float4 intersect = float4(delta * numSteps, delta * numSteps + baseTC);

	for (int i=0; i<10; i++)
	{
		[flatten]
		if (abs(error) <= 0.01)
			break;
	
		float denom = delta1 - delta0;
		float t = (t0 * delta1 - t1 * delta0) / denom;
		offsetBest.xy = -t * intersect.xy + intersect.zw;
		
		float4 NB = tex2Dlod(bumpHeightMapSampler, offsetBest);

		error = t - NB.w;
		if (error < 0)
		{
			delta1 = error;
			t1 = t;
		}
		else
		{
			delta0 = error;
			t0 = t;
		}
	}
	
	return offsetBest.xy;
}
